# Known Issues, Asymmetries, and Architectural Considerations


## Denom Trace Mapping Lives Off-Chain

Cosmos SDK chains store denom trace mappings in a consensus-state KVStore, but Cardano’s UTxO model does not provide an equivalent general-purpose on-chain key-value store. Voucher tokens embed the denom trace hash in their token names, which preserves authenticity, but the reverse lookup from hash to full trace must be maintained off-chain (for example in the Gateway’s database). The mapping is fully reconstructible from on-chain data because voucher minting transactions contain the full fungible token packet data while simultaneously minting a voucher whose token name is derived from that denom. In practice denom trace queries rely on off-chain indexing infrastructure rather than direct chain state queries, and we should continue to track this asymmetry and decide whether additional on-chain data or standardized rebuild tooling is needed.

## Underlying Cryptography

There are two different membership and non-membership problems in IBC, and the asymmetry between Tendermint and Cardano matters in different ways depending on which direction verification is happening.

When Cardano verifies Cosmos state, it follows the standard ICS-07 flow: Cardano stores a trusted consensus root for the Cosmos chain from signed Tendermint headers and verifies ICS-23 membership and non-membership proofs against that root.

When a Cosmos chain verifies Cardano state there is a fundamental asymmetry. Tendermint exposes a consensus-signed `app_hash` each height, so the counterparty can treat the header as the authenticated “state root at height H” and then verify membership and non-membership by checking ICS-23 proofs against that root. Nodes and indexers are just convenient sources of proof material in this model, the verifier does not need to trust them because it is checking the header commit and the proof cryptography.

Cardano does not expose anything analogous to a Tendermint per-height quorum commit that both identifies the canonical chain and attests to an application state root. Cardano block producers do sign blocks but Ouroboros does not give an external verifier a simple “2/3+ signed commit at height H” artifact that can be verified in isolation, this is exactly what we're trying to get around with Mithril. Chain selection and finality are determined by the ledger rules and consensus protocol, and without additional machinery a counterparty that is not running a full node does not have a way to authenticate the canonical ledger view from a small amount of header data.

This is why just querying a node is not a trustless replacement for a light client. If the Cosmos chain (or its relayer) simply asks a node, an indexer, or the Gateway “what is the current HostState UTxO and datum?” then the security reduces to trusting that external party’s view of the chain. Even if the data is accurate most of the time, the verifier has no cryptographic basis to reject stale data, fork data, or fabricated data. The IBC model is that the counterparty chain authenticates the state root itself by verifying consensus finality (for example, a Tendermint 2/3+ commit) and then checking ICS-23 proofs against the committed root (`app_hash`).

In the Cardano IBC architecture in this repository, the on-chain datum on the HostState UTxO contains `ibc_state_root`, which is an application-level commitment to Cardano’s IBC key/value state. That commitment is made meaningful by script-level enforcement: every state transition that changes committed IBC state must co-spend the HostState UTxO (identified by the HostState NFT) and must update `ibc_state_root` consistently with the witness data present in the transaction, so the commitment root and the underlying state cannot diverge. This closes an “internal correctness” gap on Cardano (the operator cannot arbitrarily write a new root), but it still does not solve the “external attestation” problem. Effectively what we've done is skirted the fact that Cardano has no such analogous app hash by inventing a local one that only covers the on-chain state of the IBC host infrastructure. We're then able to use transaction outputs of attested transactions as the source of truth for how Cosmos knows about ibc host state changes that are happening on the Cardano side. 

Separately, a trustless counterparty must be able to convince itself that a specific HostState update transaction (and the exact output datum bytes containing `ibc_state_root`) is included in a sufficiently finalized view of the Cardano ledger. This is the role Mithril is intended to play in the current design: it produces stake-based certificates for transaction snapshot checkpoints and Merkle proofs of inclusion for transactions under those checkpoints. In other words, Mithril is used to authenticate that the HostState-updating transaction is really on-chain under an attested checkpoint, after which the verifier can deterministically extract the datum bytes (and therefore the root) from the certified transaction output and then use standard ICS-23 membership and non-membership proofs against that root. 

If we keep Mithril as the attestation layer in production, it also forces us to be explicit about “height” semantics. The height that a Cosmos chain can safely accept for a Cardano proof is the Mithril snapshot `block_number` (Cardano block height) of the checkpoint that certified the relevant HostState update transaction, not a Cardano slot number. This is a real asymmetry compared to Tendermint, and it has a lot of downstream implications for query semantics, proof heights, timeouts, and relayer waiting behaviour.

## UTXO Contention

TLDR: The result is that IBC transactions are serialized, which is slow, but still masked by an order of magnitude by Mithril certificate cadence. We should implement a sharding mechanism here but this is lower priority than sorting out the Mithril related latency concerns. 

The IBC HostState design treats the HostState UTxO (identified by the HostState NFT) as the single source of truth for `ibc_state_root`, every IBC state transition that changes committed state must co-spend that same UTxO to update the root. This effectively serializes all root-changing IBC operations (client, connection, channel, and packet state updates), even if they touch disjoint keys. This allows us to achieve the IBC trust constraints and cryptographic security of the bridge but it also creates contention under load. This is not a correctness problem, but it is a throughput and liveness constraint that differs materially from Cosmos SDK chains where many updates can be committed independently in the same block.

We haven't settled on a production strategy to mitigate this. Options include batching multiple IBC updates into a single HostState-spending transaction, which I think is an uglier solution,  or alternatively sharding committed IBC state into multiple independently-spendable state UTxOs (and adjusting the commitment model and light client verification accordingly) so unrelated flows do not contend on a single global input. This will likely be a complex and challenging solution but I believe is the more "correct" path forward.



## Constrained by Mithril Certificate Frequency

It should be clear that Mithril certificates are **not** produced on a per-block basis. On Cosmos chains IBC proofs are available at essentially every block height because the counterparty can verify ICS-23 proofs against the consensus-signed `app_hash` of that height. In the current Cardano to Cosmos direction, the Cosmos chain instead anchors Cardano IBC state by verifying that a specific HostState-updating transaction is included in a Mithril-certified transaction snapshot, and then extracting the HostState datum bytes (and `ibc_state_root`) from that certified evidence. This means cross-chain progress is bottlenecked by certificate issuance and snapshot publication. If certificates are produced on the order of minutes then a HostState update can be observed by the Gateway immediately but cannot be used as a verifiable proof on the Cosmos chain until it is covered by a certificate. 

This also introduces a height asymmetry: the proof height that the Cosmos chain can safely accept is the Mithril-certified snapshot height and not a Cardano slot number. If we keep Mithril as the attestation layer in production, we need to ensure the Gateway and relayer treat this consistently as the “proof height”, and we need to ensure our retry and waiting behaviour is driven by observed snapshot progression rather than arbitrary sleep intervals.
