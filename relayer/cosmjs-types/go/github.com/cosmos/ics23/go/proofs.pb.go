// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0-devel
// 	protoc        (unknown)
// source: cosmos/ics23/v1/proofs.proto

package ics23

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type HashOp int32

const (
	// NO_HASH is the default if no data passed. Note this is an illegal argument some places.
	HashOp_NO_HASH    HashOp = 0
	HashOp_SHA256     HashOp = 1
	HashOp_SHA512     HashOp = 2
	HashOp_KECCAK     HashOp = 3
	HashOp_RIPEMD160  HashOp = 4
	HashOp_BITCOIN    HashOp = 5 // ripemd160(sha256(x))
	HashOp_SHA512_256 HashOp = 6
)

// Enum value maps for HashOp.
var (
	HashOp_name = map[int32]string{
		0: "NO_HASH",
		1: "SHA256",
		2: "SHA512",
		3: "KECCAK",
		4: "RIPEMD160",
		5: "BITCOIN",
		6: "SHA512_256",
	}
	HashOp_value = map[string]int32{
		"NO_HASH":    0,
		"SHA256":     1,
		"SHA512":     2,
		"KECCAK":     3,
		"RIPEMD160":  4,
		"BITCOIN":    5,
		"SHA512_256": 6,
	}
)

func (x HashOp) Enum() *HashOp {
	p := new(HashOp)
	*p = x
	return p
}

func (x HashOp) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HashOp) Descriptor() protoreflect.EnumDescriptor {
	return file_cosmos_ics23_v1_proofs_proto_enumTypes[0].Descriptor()
}

func (HashOp) Type() protoreflect.EnumType {
	return &file_cosmos_ics23_v1_proofs_proto_enumTypes[0]
}

func (x HashOp) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HashOp.Descriptor instead.
func (HashOp) EnumDescriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{0}
}

//
//LengthOp defines how to process the key and value of the LeafOp
//to include length information. After encoding the length with the given
//algorithm, the length will be prepended to the key and value bytes.
//(Each one with it's own encoded length)
type LengthOp int32

const (
	// NO_PREFIX don't include any length info
	LengthOp_NO_PREFIX LengthOp = 0
	// VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
	LengthOp_VAR_PROTO LengthOp = 1
	// VAR_RLP uses rlp int encoding of the length
	LengthOp_VAR_RLP LengthOp = 2
	// FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
	LengthOp_FIXED32_BIG LengthOp = 3
	// FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
	LengthOp_FIXED32_LITTLE LengthOp = 4
	// FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
	LengthOp_FIXED64_BIG LengthOp = 5
	// FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
	LengthOp_FIXED64_LITTLE LengthOp = 6
	// REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
	LengthOp_REQUIRE_32_BYTES LengthOp = 7
	// REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
	LengthOp_REQUIRE_64_BYTES LengthOp = 8
)

// Enum value maps for LengthOp.
var (
	LengthOp_name = map[int32]string{
		0: "NO_PREFIX",
		1: "VAR_PROTO",
		2: "VAR_RLP",
		3: "FIXED32_BIG",
		4: "FIXED32_LITTLE",
		5: "FIXED64_BIG",
		6: "FIXED64_LITTLE",
		7: "REQUIRE_32_BYTES",
		8: "REQUIRE_64_BYTES",
	}
	LengthOp_value = map[string]int32{
		"NO_PREFIX":        0,
		"VAR_PROTO":        1,
		"VAR_RLP":          2,
		"FIXED32_BIG":      3,
		"FIXED32_LITTLE":   4,
		"FIXED64_BIG":      5,
		"FIXED64_LITTLE":   6,
		"REQUIRE_32_BYTES": 7,
		"REQUIRE_64_BYTES": 8,
	}
)

func (x LengthOp) Enum() *LengthOp {
	p := new(LengthOp)
	*p = x
	return p
}

func (x LengthOp) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LengthOp) Descriptor() protoreflect.EnumDescriptor {
	return file_cosmos_ics23_v1_proofs_proto_enumTypes[1].Descriptor()
}

func (LengthOp) Type() protoreflect.EnumType {
	return &file_cosmos_ics23_v1_proofs_proto_enumTypes[1]
}

func (x LengthOp) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LengthOp.Descriptor instead.
func (LengthOp) EnumDescriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{1}
}

//
//ExistenceProof takes a key and a value and a set of steps to perform on it.
//The result of peforming all these steps will provide a "root hash", which can
//be compared to the value in a header.
//
//Since it is computationally infeasible to produce a hash collission for any of the used
//cryptographic hash functions, if someone can provide a series of operations to transform
//a given key and value into a root hash that matches some trusted root, these key and values
//must be in the referenced merkle tree.
//
//The only possible issue is maliablity in LeafOp, such as providing extra prefix data,
//which should be controlled by a spec. Eg. with lengthOp as NONE,
// prefix = FOO, key = BAR, value = CHOICE
//and
// prefix = F, key = OOBAR, value = CHOICE
//would produce the same value.
//
//With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field
//in the ProofSpec is valuable to prevent this mutability. And why all trees should
//length-prefix the data before hashing it.
type ExistenceProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   []byte     `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte     `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Leaf  *LeafOp    `protobuf:"bytes,3,opt,name=leaf,proto3" json:"leaf,omitempty"`
	Path  []*InnerOp `protobuf:"bytes,4,rep,name=path,proto3" json:"path,omitempty"`
}

func (x *ExistenceProof) Reset() {
	*x = ExistenceProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExistenceProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExistenceProof) ProtoMessage() {}

func (x *ExistenceProof) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExistenceProof.ProtoReflect.Descriptor instead.
func (*ExistenceProof) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{0}
}

func (x *ExistenceProof) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *ExistenceProof) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *ExistenceProof) GetLeaf() *LeafOp {
	if x != nil {
		return x.Leaf
	}
	return nil
}

func (x *ExistenceProof) GetPath() []*InnerOp {
	if x != nil {
		return x.Path
	}
	return nil
}

//
//NonExistenceProof takes a proof of two neighbors, one left of the desired key,
//one right of the desired key. If both proofs are valid AND they are neighbors,
//then there is no valid proof for the given key.
type NonExistenceProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   []byte          `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"` // TODO: remove this as unnecessary??? we prove a range
	Left  *ExistenceProof `protobuf:"bytes,2,opt,name=left,proto3" json:"left,omitempty"`
	Right *ExistenceProof `protobuf:"bytes,3,opt,name=right,proto3" json:"right,omitempty"`
}

func (x *NonExistenceProof) Reset() {
	*x = NonExistenceProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NonExistenceProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NonExistenceProof) ProtoMessage() {}

func (x *NonExistenceProof) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NonExistenceProof.ProtoReflect.Descriptor instead.
func (*NonExistenceProof) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{1}
}

func (x *NonExistenceProof) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *NonExistenceProof) GetLeft() *ExistenceProof {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *NonExistenceProof) GetRight() *ExistenceProof {
	if x != nil {
		return x.Right
	}
	return nil
}

//
//CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
type CommitmentProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Proof:
	//	*CommitmentProof_Exist
	//	*CommitmentProof_Nonexist
	//	*CommitmentProof_Batch
	//	*CommitmentProof_Compressed
	Proof isCommitmentProof_Proof `protobuf_oneof:"proof"`
}

func (x *CommitmentProof) Reset() {
	*x = CommitmentProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitmentProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitmentProof) ProtoMessage() {}

func (x *CommitmentProof) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitmentProof.ProtoReflect.Descriptor instead.
func (*CommitmentProof) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{2}
}

func (m *CommitmentProof) GetProof() isCommitmentProof_Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (x *CommitmentProof) GetExist() *ExistenceProof {
	if x, ok := x.GetProof().(*CommitmentProof_Exist); ok {
		return x.Exist
	}
	return nil
}

func (x *CommitmentProof) GetNonexist() *NonExistenceProof {
	if x, ok := x.GetProof().(*CommitmentProof_Nonexist); ok {
		return x.Nonexist
	}
	return nil
}

func (x *CommitmentProof) GetBatch() *BatchProof {
	if x, ok := x.GetProof().(*CommitmentProof_Batch); ok {
		return x.Batch
	}
	return nil
}

func (x *CommitmentProof) GetCompressed() *CompressedBatchProof {
	if x, ok := x.GetProof().(*CommitmentProof_Compressed); ok {
		return x.Compressed
	}
	return nil
}

type isCommitmentProof_Proof interface {
	isCommitmentProof_Proof()
}

type CommitmentProof_Exist struct {
	Exist *ExistenceProof `protobuf:"bytes,1,opt,name=exist,proto3,oneof"`
}

type CommitmentProof_Nonexist struct {
	Nonexist *NonExistenceProof `protobuf:"bytes,2,opt,name=nonexist,proto3,oneof"`
}

type CommitmentProof_Batch struct {
	Batch *BatchProof `protobuf:"bytes,3,opt,name=batch,proto3,oneof"`
}

type CommitmentProof_Compressed struct {
	Compressed *CompressedBatchProof `protobuf:"bytes,4,opt,name=compressed,proto3,oneof"`
}

func (*CommitmentProof_Exist) isCommitmentProof_Proof() {}

func (*CommitmentProof_Nonexist) isCommitmentProof_Proof() {}

func (*CommitmentProof_Batch) isCommitmentProof_Proof() {}

func (*CommitmentProof_Compressed) isCommitmentProof_Proof() {}

//
//LeafOp represents the raw key-value data we wish to prove, and
//must be flexible to represent the internal transformation from
//the original key-value pairs into the basis hash, for many existing
//merkle trees.
//
//key and value are passed in. So that the signature of this operation is:
// leafOp(key, value) -> output
//
//To process this, first prehash the keys and values if needed (ANY means no hash in this case):
// hkey = prehashKey(key)
// hvalue = prehashValue(value)
//
//Then combine the bytes, and hash it
// output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
type LeafOp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Hash         HashOp   `protobuf:"varint,1,opt,name=hash,proto3,enum=cosmos.ics23.v1.HashOp" json:"hash,omitempty"`
	PrehashKey   HashOp   `protobuf:"varint,2,opt,name=prehash_key,json=prehashKey,proto3,enum=cosmos.ics23.v1.HashOp" json:"prehash_key,omitempty"`
	PrehashValue HashOp   `protobuf:"varint,3,opt,name=prehash_value,json=prehashValue,proto3,enum=cosmos.ics23.v1.HashOp" json:"prehash_value,omitempty"`
	Length       LengthOp `protobuf:"varint,4,opt,name=length,proto3,enum=cosmos.ics23.v1.LengthOp" json:"length,omitempty"`
	// prefix is a fixed bytes that may optionally be included at the beginning to differentiate
	// a leaf node from an inner node.
	Prefix []byte `protobuf:"bytes,5,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (x *LeafOp) Reset() {
	*x = LeafOp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LeafOp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LeafOp) ProtoMessage() {}

func (x *LeafOp) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LeafOp.ProtoReflect.Descriptor instead.
func (*LeafOp) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{3}
}

func (x *LeafOp) GetHash() HashOp {
	if x != nil {
		return x.Hash
	}
	return HashOp_NO_HASH
}

func (x *LeafOp) GetPrehashKey() HashOp {
	if x != nil {
		return x.PrehashKey
	}
	return HashOp_NO_HASH
}

func (x *LeafOp) GetPrehashValue() HashOp {
	if x != nil {
		return x.PrehashValue
	}
	return HashOp_NO_HASH
}

func (x *LeafOp) GetLength() LengthOp {
	if x != nil {
		return x.Length
	}
	return LengthOp_NO_PREFIX
}

func (x *LeafOp) GetPrefix() []byte {
	if x != nil {
		return x.Prefix
	}
	return nil
}

//
//InnerOp represents a merkle-proof step that is not a leaf.
//It represents concatenating two children and hashing them to provide the next result.
//
//The result of the previous step is passed in, so the signature of this op is:
// innerOp(child) -> output
//
//The result of applying InnerOp should be:
// output = op.hash(op.prefix || child || op.suffix)
//
// where the || operator is concatenation of binary data,
//and child is the result of hashing all the tree below this step.
//
//Any special data, like prepending child with the length, or prepending the entire operation with
//some value to differentiate from leaf nodes, should be included in prefix and suffix.
//If either of prefix or suffix is empty, we just treat it as an empty string
type InnerOp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Hash   HashOp `protobuf:"varint,1,opt,name=hash,proto3,enum=cosmos.ics23.v1.HashOp" json:"hash,omitempty"`
	Prefix []byte `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Suffix []byte `protobuf:"bytes,3,opt,name=suffix,proto3" json:"suffix,omitempty"`
}

func (x *InnerOp) Reset() {
	*x = InnerOp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *InnerOp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InnerOp) ProtoMessage() {}

func (x *InnerOp) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InnerOp.ProtoReflect.Descriptor instead.
func (*InnerOp) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{4}
}

func (x *InnerOp) GetHash() HashOp {
	if x != nil {
		return x.Hash
	}
	return HashOp_NO_HASH
}

func (x *InnerOp) GetPrefix() []byte {
	if x != nil {
		return x.Prefix
	}
	return nil
}

func (x *InnerOp) GetSuffix() []byte {
	if x != nil {
		return x.Suffix
	}
	return nil
}

//
//ProofSpec defines what the expected parameters are for a given proof type.
//This can be stored in the client and used to validate any incoming proofs.
//
// verify(ProofSpec, Proof) -> Proof | Error
//
//As demonstrated in tests, if we don't fix the algorithm used to calculate the
//LeafHash for a given tree, there are many possible key-value pairs that can
//generate a given hash (by interpretting the preimage differently).
//We need this for proper security, requires client knows a priori what
//tree format server uses. But not in code, rather a configuration object.
type ProofSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// any field in the ExistenceProof must be the same as in this spec.
	// except Prefix, which is just the first bytes of prefix (spec can be longer)
	LeafSpec  *LeafOp    `protobuf:"bytes,1,opt,name=leaf_spec,json=leafSpec,proto3" json:"leaf_spec,omitempty"`
	InnerSpec *InnerSpec `protobuf:"bytes,2,opt,name=inner_spec,json=innerSpec,proto3" json:"inner_spec,omitempty"`
	// max_depth (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
	MaxDepth int32 `protobuf:"varint,3,opt,name=max_depth,json=maxDepth,proto3" json:"max_depth,omitempty"`
	// min_depth (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
	MinDepth int32 `protobuf:"varint,4,opt,name=min_depth,json=minDepth,proto3" json:"min_depth,omitempty"`
}

func (x *ProofSpec) Reset() {
	*x = ProofSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ProofSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProofSpec) ProtoMessage() {}

func (x *ProofSpec) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProofSpec.ProtoReflect.Descriptor instead.
func (*ProofSpec) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{5}
}

func (x *ProofSpec) GetLeafSpec() *LeafOp {
	if x != nil {
		return x.LeafSpec
	}
	return nil
}

func (x *ProofSpec) GetInnerSpec() *InnerSpec {
	if x != nil {
		return x.InnerSpec
	}
	return nil
}

func (x *ProofSpec) GetMaxDepth() int32 {
	if x != nil {
		return x.MaxDepth
	}
	return 0
}

func (x *ProofSpec) GetMinDepth() int32 {
	if x != nil {
		return x.MinDepth
	}
	return 0
}

//
//InnerSpec contains all store-specific structure info to determine if two proofs from a
//given store are neighbors.
//
//This enables:
//
// isLeftMost(spec: InnerSpec, op: InnerOp)
// isRightMost(spec: InnerSpec, op: InnerOp)
// isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
type InnerSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Child order is the ordering of the children node, must count from 0
	// iavl tree is [0, 1] (left then right)
	// merk is [0, 2, 1] (left, right, here)
	ChildOrder      []int32 `protobuf:"varint,1,rep,packed,name=child_order,json=childOrder,proto3" json:"child_order,omitempty"`
	ChildSize       int32   `protobuf:"varint,2,opt,name=child_size,json=childSize,proto3" json:"child_size,omitempty"`
	MinPrefixLength int32   `protobuf:"varint,3,opt,name=min_prefix_length,json=minPrefixLength,proto3" json:"min_prefix_length,omitempty"`
	MaxPrefixLength int32   `protobuf:"varint,4,opt,name=max_prefix_length,json=maxPrefixLength,proto3" json:"max_prefix_length,omitempty"`
	// empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
	EmptyChild []byte `protobuf:"bytes,5,opt,name=empty_child,json=emptyChild,proto3" json:"empty_child,omitempty"`
	// hash is the algorithm that must be used for each InnerOp
	Hash HashOp `protobuf:"varint,6,opt,name=hash,proto3,enum=cosmos.ics23.v1.HashOp" json:"hash,omitempty"`
}

func (x *InnerSpec) Reset() {
	*x = InnerSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *InnerSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InnerSpec) ProtoMessage() {}

func (x *InnerSpec) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InnerSpec.ProtoReflect.Descriptor instead.
func (*InnerSpec) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{6}
}

func (x *InnerSpec) GetChildOrder() []int32 {
	if x != nil {
		return x.ChildOrder
	}
	return nil
}

func (x *InnerSpec) GetChildSize() int32 {
	if x != nil {
		return x.ChildSize
	}
	return 0
}

func (x *InnerSpec) GetMinPrefixLength() int32 {
	if x != nil {
		return x.MinPrefixLength
	}
	return 0
}

func (x *InnerSpec) GetMaxPrefixLength() int32 {
	if x != nil {
		return x.MaxPrefixLength
	}
	return 0
}

func (x *InnerSpec) GetEmptyChild() []byte {
	if x != nil {
		return x.EmptyChild
	}
	return nil
}

func (x *InnerSpec) GetHash() HashOp {
	if x != nil {
		return x.Hash
	}
	return HashOp_NO_HASH
}

//
//BatchProof is a group of multiple proof types than can be compressed
type BatchProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Entries []*BatchEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (x *BatchProof) Reset() {
	*x = BatchProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchProof) ProtoMessage() {}

func (x *BatchProof) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchProof.ProtoReflect.Descriptor instead.
func (*BatchProof) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{7}
}

func (x *BatchProof) GetEntries() []*BatchEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// Use BatchEntry not CommitmentProof, to avoid recursion
type BatchEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Proof:
	//	*BatchEntry_Exist
	//	*BatchEntry_Nonexist
	Proof isBatchEntry_Proof `protobuf_oneof:"proof"`
}

func (x *BatchEntry) Reset() {
	*x = BatchEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchEntry) ProtoMessage() {}

func (x *BatchEntry) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchEntry.ProtoReflect.Descriptor instead.
func (*BatchEntry) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{8}
}

func (m *BatchEntry) GetProof() isBatchEntry_Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (x *BatchEntry) GetExist() *ExistenceProof {
	if x, ok := x.GetProof().(*BatchEntry_Exist); ok {
		return x.Exist
	}
	return nil
}

func (x *BatchEntry) GetNonexist() *NonExistenceProof {
	if x, ok := x.GetProof().(*BatchEntry_Nonexist); ok {
		return x.Nonexist
	}
	return nil
}

type isBatchEntry_Proof interface {
	isBatchEntry_Proof()
}

type BatchEntry_Exist struct {
	Exist *ExistenceProof `protobuf:"bytes,1,opt,name=exist,proto3,oneof"`
}

type BatchEntry_Nonexist struct {
	Nonexist *NonExistenceProof `protobuf:"bytes,2,opt,name=nonexist,proto3,oneof"`
}

func (*BatchEntry_Exist) isBatchEntry_Proof() {}

func (*BatchEntry_Nonexist) isBatchEntry_Proof() {}

type CompressedBatchProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Entries      []*CompressedBatchEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	LookupInners []*InnerOp              `protobuf:"bytes,2,rep,name=lookup_inners,json=lookupInners,proto3" json:"lookup_inners,omitempty"`
}

func (x *CompressedBatchProof) Reset() {
	*x = CompressedBatchProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CompressedBatchProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompressedBatchProof) ProtoMessage() {}

func (x *CompressedBatchProof) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompressedBatchProof.ProtoReflect.Descriptor instead.
func (*CompressedBatchProof) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{9}
}

func (x *CompressedBatchProof) GetEntries() []*CompressedBatchEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

func (x *CompressedBatchProof) GetLookupInners() []*InnerOp {
	if x != nil {
		return x.LookupInners
	}
	return nil
}

// Use BatchEntry not CommitmentProof, to avoid recursion
type CompressedBatchEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Proof:
	//	*CompressedBatchEntry_Exist
	//	*CompressedBatchEntry_Nonexist
	Proof isCompressedBatchEntry_Proof `protobuf_oneof:"proof"`
}

func (x *CompressedBatchEntry) Reset() {
	*x = CompressedBatchEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CompressedBatchEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompressedBatchEntry) ProtoMessage() {}

func (x *CompressedBatchEntry) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompressedBatchEntry.ProtoReflect.Descriptor instead.
func (*CompressedBatchEntry) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{10}
}

func (m *CompressedBatchEntry) GetProof() isCompressedBatchEntry_Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (x *CompressedBatchEntry) GetExist() *CompressedExistenceProof {
	if x, ok := x.GetProof().(*CompressedBatchEntry_Exist); ok {
		return x.Exist
	}
	return nil
}

func (x *CompressedBatchEntry) GetNonexist() *CompressedNonExistenceProof {
	if x, ok := x.GetProof().(*CompressedBatchEntry_Nonexist); ok {
		return x.Nonexist
	}
	return nil
}

type isCompressedBatchEntry_Proof interface {
	isCompressedBatchEntry_Proof()
}

type CompressedBatchEntry_Exist struct {
	Exist *CompressedExistenceProof `protobuf:"bytes,1,opt,name=exist,proto3,oneof"`
}

type CompressedBatchEntry_Nonexist struct {
	Nonexist *CompressedNonExistenceProof `protobuf:"bytes,2,opt,name=nonexist,proto3,oneof"`
}

func (*CompressedBatchEntry_Exist) isCompressedBatchEntry_Proof() {}

func (*CompressedBatchEntry_Nonexist) isCompressedBatchEntry_Proof() {}

type CompressedExistenceProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   []byte  `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte  `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Leaf  *LeafOp `protobuf:"bytes,3,opt,name=leaf,proto3" json:"leaf,omitempty"`
	// these are indexes into the lookup_inners table in CompressedBatchProof
	Path []int32 `protobuf:"varint,4,rep,packed,name=path,proto3" json:"path,omitempty"`
}

func (x *CompressedExistenceProof) Reset() {
	*x = CompressedExistenceProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CompressedExistenceProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompressedExistenceProof) ProtoMessage() {}

func (x *CompressedExistenceProof) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompressedExistenceProof.ProtoReflect.Descriptor instead.
func (*CompressedExistenceProof) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{11}
}

func (x *CompressedExistenceProof) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *CompressedExistenceProof) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *CompressedExistenceProof) GetLeaf() *LeafOp {
	if x != nil {
		return x.Leaf
	}
	return nil
}

func (x *CompressedExistenceProof) GetPath() []int32 {
	if x != nil {
		return x.Path
	}
	return nil
}

type CompressedNonExistenceProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   []byte                    `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"` // TODO: remove this as unnecessary??? we prove a range
	Left  *CompressedExistenceProof `protobuf:"bytes,2,opt,name=left,proto3" json:"left,omitempty"`
	Right *CompressedExistenceProof `protobuf:"bytes,3,opt,name=right,proto3" json:"right,omitempty"`
}

func (x *CompressedNonExistenceProof) Reset() {
	*x = CompressedNonExistenceProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CompressedNonExistenceProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompressedNonExistenceProof) ProtoMessage() {}

func (x *CompressedNonExistenceProof) ProtoReflect() protoreflect.Message {
	mi := &file_cosmos_ics23_v1_proofs_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompressedNonExistenceProof.ProtoReflect.Descriptor instead.
func (*CompressedNonExistenceProof) Descriptor() ([]byte, []int) {
	return file_cosmos_ics23_v1_proofs_proto_rawDescGZIP(), []int{12}
}

func (x *CompressedNonExistenceProof) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *CompressedNonExistenceProof) GetLeft() *CompressedExistenceProof {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *CompressedNonExistenceProof) GetRight() *CompressedExistenceProof {
	if x != nil {
		return x.Right
	}
	return nil
}

var File_cosmos_ics23_v1_proofs_proto protoreflect.FileDescriptor

var file_cosmos_ics23_v1_proofs_proto_rawDesc = []byte{
	0x0a, 0x1c, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2f, 0x76,
	0x31, 0x2f, 0x70, 0x72, 0x6f, 0x6f, 0x66, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0f,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x22,
	0x93, 0x01, 0x0a, 0x0e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f,
	0x6f, 0x66, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0c, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x2b, 0x0a, 0x04, 0x6c, 0x65,
	0x61, 0x66, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x65, 0x61, 0x66, 0x4f,
	0x70, 0x52, 0x04, 0x6c, 0x65, 0x61, 0x66, 0x12, 0x2c, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18,
	0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69,
	0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x4f, 0x70, 0x52,
	0x04, 0x70, 0x61, 0x74, 0x68, 0x22, 0x91, 0x01, 0x0a, 0x11, 0x4e, 0x6f, 0x6e, 0x45, 0x78, 0x69,
	0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x10, 0x0a, 0x03, 0x6b,
	0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x33, 0x0a,
	0x04, 0x6c, 0x65, 0x66, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78,
	0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x52, 0x04, 0x6c, 0x65,
	0x66, 0x74, 0x12, 0x35, 0x0a, 0x05, 0x72, 0x69, 0x67, 0x68, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1f, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33,
	0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f,
	0x6f, 0x66, 0x52, 0x05, 0x72, 0x69, 0x67, 0x68, 0x74, 0x22, 0x93, 0x02, 0x0a, 0x0f, 0x43, 0x6f,
	0x6d, 0x6d, 0x69, 0x74, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x37, 0x0a,
	0x05, 0x65, 0x78, 0x69, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x45,
	0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52,
	0x05, 0x65, 0x78, 0x69, 0x73, 0x74, 0x12, 0x40, 0x0a, 0x08, 0x6e, 0x6f, 0x6e, 0x65, 0x78, 0x69,
	0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x6f, 0x6e, 0x45, 0x78,
	0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52, 0x08,
	0x6e, 0x6f, 0x6e, 0x65, 0x78, 0x69, 0x73, 0x74, 0x12, 0x33, 0x0a, 0x05, 0x62, 0x61, 0x74, 0x63,
	0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x50,
	0x72, 0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52, 0x05, 0x62, 0x61, 0x74, 0x63, 0x68, 0x12, 0x47, 0x0a,
	0x0a, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x25, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33,
	0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x42, 0x61,
	0x74, 0x63, 0x68, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52, 0x0a, 0x63, 0x6f, 0x6d, 0x70,
	0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x42, 0x07, 0x0a, 0x05, 0x70, 0x72, 0x6f, 0x6f, 0x66, 0x22,
	0xf8, 0x01, 0x0a, 0x06, 0x4c, 0x65, 0x61, 0x66, 0x4f, 0x70, 0x12, 0x2b, 0x0a, 0x04, 0x68, 0x61,
	0x73, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x4f,
	0x70, 0x52, 0x04, 0x68, 0x61, 0x73, 0x68, 0x12, 0x38, 0x0a, 0x0b, 0x70, 0x72, 0x65, 0x68, 0x61,
	0x73, 0x68, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x48,
	0x61, 0x73, 0x68, 0x4f, 0x70, 0x52, 0x0a, 0x70, 0x72, 0x65, 0x68, 0x61, 0x73, 0x68, 0x4b, 0x65,
	0x79, 0x12, 0x3c, 0x0a, 0x0d, 0x70, 0x72, 0x65, 0x68, 0x61, 0x73, 0x68, 0x5f, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x4f,
	0x70, 0x52, 0x0c, 0x70, 0x72, 0x65, 0x68, 0x61, 0x73, 0x68, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12,
	0x31, 0x0a, 0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x19, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76,
	0x31, 0x2e, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x4f, 0x70, 0x52, 0x06, 0x6c, 0x65, 0x6e, 0x67,
	0x74, 0x68, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0c, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x22, 0x66, 0x0a, 0x07, 0x49, 0x6e,
	0x6e, 0x65, 0x72, 0x4f, 0x70, 0x12, 0x2b, 0x0a, 0x04, 0x68, 0x61, 0x73, 0x68, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73,
	0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x4f, 0x70, 0x52, 0x04, 0x68, 0x61,
	0x73, 0x68, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0c, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x75,
	0x66, 0x66, 0x69, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x73, 0x75, 0x66, 0x66,
	0x69, 0x78, 0x22, 0xb6, 0x01, 0x0a, 0x09, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x53, 0x70, 0x65, 0x63,
	0x12, 0x34, 0x0a, 0x09, 0x6c, 0x65, 0x61, 0x66, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73,
	0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x65, 0x61, 0x66, 0x4f, 0x70, 0x52, 0x08, 0x6c, 0x65,
	0x61, 0x66, 0x53, 0x70, 0x65, 0x63, 0x12, 0x39, 0x0a, 0x0a, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x5f,
	0x73, 0x70, 0x65, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x6e,
	0x65, 0x72, 0x53, 0x70, 0x65, 0x63, 0x52, 0x09, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x53, 0x70, 0x65,
	0x63, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x78, 0x5f, 0x64, 0x65, 0x70, 0x74, 0x68, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x6d, 0x61, 0x78, 0x44, 0x65, 0x70, 0x74, 0x68, 0x12, 0x1b,
	0x0a, 0x09, 0x6d, 0x69, 0x6e, 0x5f, 0x64, 0x65, 0x70, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x08, 0x6d, 0x69, 0x6e, 0x44, 0x65, 0x70, 0x74, 0x68, 0x22, 0xf1, 0x01, 0x0a, 0x09,
	0x49, 0x6e, 0x6e, 0x65, 0x72, 0x53, 0x70, 0x65, 0x63, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x68, 0x69,
	0x6c, 0x64, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0a,
	0x63, 0x68, 0x69, 0x6c, 0x64, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x68,
	0x69, 0x6c, 0x64, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09,
	0x63, 0x68, 0x69, 0x6c, 0x64, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x2a, 0x0a, 0x11, 0x6d, 0x69, 0x6e,
	0x5f, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x6d, 0x69, 0x6e, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x4c,
	0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x2a, 0x0a, 0x11, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x72, 0x65,
	0x66, 0x69, 0x78, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x0f, 0x6d, 0x61, 0x78, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74,
	0x68, 0x12, 0x1f, 0x0a, 0x0b, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x5f, 0x63, 0x68, 0x69, 0x6c, 0x64,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0a, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x43, 0x68, 0x69,
	0x6c, 0x64, 0x12, 0x2b, 0x0a, 0x04, 0x68, 0x61, 0x73, 0x68, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x17, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e,
	0x76, 0x31, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x4f, 0x70, 0x52, 0x04, 0x68, 0x61, 0x73, 0x68, 0x22,
	0x43, 0x0a, 0x0a, 0x42, 0x61, 0x74, 0x63, 0x68, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x35, 0x0a,
	0x07, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b,
	0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31,
	0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x65, 0x6e, 0x74,
	0x72, 0x69, 0x65, 0x73, 0x22, 0x90, 0x01, 0x0a, 0x0a, 0x42, 0x61, 0x74, 0x63, 0x68, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x12, 0x37, 0x0a, 0x05, 0x65, 0x78, 0x69, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32,
	0x33, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72,
	0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52, 0x05, 0x65, 0x78, 0x69, 0x73, 0x74, 0x12, 0x40, 0x0a, 0x08,
	0x6e, 0x6f, 0x6e, 0x65, 0x78, 0x69, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22,
	0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31,
	0x2e, 0x4e, 0x6f, 0x6e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f,
	0x6f, 0x66, 0x48, 0x00, 0x52, 0x08, 0x6e, 0x6f, 0x6e, 0x65, 0x78, 0x69, 0x73, 0x74, 0x42, 0x07,
	0x0a, 0x05, 0x70, 0x72, 0x6f, 0x6f, 0x66, 0x22, 0x96, 0x01, 0x0a, 0x14, 0x43, 0x6f, 0x6d, 0x70,
	0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x42, 0x61, 0x74, 0x63, 0x68, 0x50, 0x72, 0x6f, 0x6f, 0x66,
	0x12, 0x3f, 0x0a, 0x07, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x25, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33,
	0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x42, 0x61,
	0x74, 0x63, 0x68, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65,
	0x73, 0x12, 0x3d, 0x0a, 0x0d, 0x6c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x5f, 0x69, 0x6e, 0x6e, 0x65,
	0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e, 0x6e, 0x65, 0x72,
	0x4f, 0x70, 0x52, 0x0c, 0x6c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x49, 0x6e, 0x6e, 0x65, 0x72, 0x73,
	0x22, 0xae, 0x01, 0x0a, 0x14, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x42,
	0x61, 0x74, 0x63, 0x68, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x41, 0x0a, 0x05, 0x65, 0x78, 0x69,
	0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72,
	0x65, 0x73, 0x73, 0x65, 0x64, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72,
	0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52, 0x05, 0x65, 0x78, 0x69, 0x73, 0x74, 0x12, 0x4a, 0x0a, 0x08,
	0x6e, 0x6f, 0x6e, 0x65, 0x78, 0x69, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c,
	0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31,
	0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x4e, 0x6f, 0x6e, 0x45, 0x78,
	0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x48, 0x00, 0x52, 0x08,
	0x6e, 0x6f, 0x6e, 0x65, 0x78, 0x69, 0x73, 0x74, 0x42, 0x07, 0x0a, 0x05, 0x70, 0x72, 0x6f, 0x6f,
	0x66, 0x22, 0x83, 0x01, 0x0a, 0x18, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64,
	0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x10,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x2b, 0x0a, 0x04, 0x6c, 0x65, 0x61, 0x66, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x69, 0x63,
	0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x65, 0x61, 0x66, 0x4f, 0x70, 0x52, 0x04, 0x6c,
	0x65, 0x61, 0x66, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x04, 0x20, 0x03, 0x28,
	0x05, 0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x22, 0xaf, 0x01, 0x0a, 0x1b, 0x43, 0x6f, 0x6d, 0x70,
	0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x4e, 0x6f, 0x6e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e,
	0x63, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x3d, 0x0a, 0x04, 0x6c, 0x65, 0x66,
	0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65,
	0x73, 0x73, 0x65, 0x64, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f,
	0x6f, 0x66, 0x52, 0x04, 0x6c, 0x65, 0x66, 0x74, 0x12, 0x3f, 0x0a, 0x05, 0x72, 0x69, 0x67, 0x68,
	0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2e, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65,
	0x73, 0x73, 0x65, 0x64, 0x45, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f,
	0x6f, 0x66, 0x52, 0x05, 0x72, 0x69, 0x67, 0x68, 0x74, 0x2a, 0x65, 0x0a, 0x06, 0x48, 0x61, 0x73,
	0x68, 0x4f, 0x70, 0x12, 0x0b, 0x0a, 0x07, 0x4e, 0x4f, 0x5f, 0x48, 0x41, 0x53, 0x48, 0x10, 0x00,
	0x12, 0x0a, 0x0a, 0x06, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06,
	0x53, 0x48, 0x41, 0x35, 0x31, 0x32, 0x10, 0x02, 0x12, 0x0a, 0x0a, 0x06, 0x4b, 0x45, 0x43, 0x43,
	0x41, 0x4b, 0x10, 0x03, 0x12, 0x0d, 0x0a, 0x09, 0x52, 0x49, 0x50, 0x45, 0x4d, 0x44, 0x31, 0x36,
	0x30, 0x10, 0x04, 0x12, 0x0b, 0x0a, 0x07, 0x42, 0x49, 0x54, 0x43, 0x4f, 0x49, 0x4e, 0x10, 0x05,
	0x12, 0x0e, 0x0a, 0x0a, 0x53, 0x48, 0x41, 0x35, 0x31, 0x32, 0x5f, 0x32, 0x35, 0x36, 0x10, 0x06,
	0x2a, 0xab, 0x01, 0x0a, 0x08, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x4f, 0x70, 0x12, 0x0d, 0x0a,
	0x09, 0x4e, 0x4f, 0x5f, 0x50, 0x52, 0x45, 0x46, 0x49, 0x58, 0x10, 0x00, 0x12, 0x0d, 0x0a, 0x09,
	0x56, 0x41, 0x52, 0x5f, 0x50, 0x52, 0x4f, 0x54, 0x4f, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x56,
	0x41, 0x52, 0x5f, 0x52, 0x4c, 0x50, 0x10, 0x02, 0x12, 0x0f, 0x0a, 0x0b, 0x46, 0x49, 0x58, 0x45,
	0x44, 0x33, 0x32, 0x5f, 0x42, 0x49, 0x47, 0x10, 0x03, 0x12, 0x12, 0x0a, 0x0e, 0x46, 0x49, 0x58,
	0x45, 0x44, 0x33, 0x32, 0x5f, 0x4c, 0x49, 0x54, 0x54, 0x4c, 0x45, 0x10, 0x04, 0x12, 0x0f, 0x0a,
	0x0b, 0x46, 0x49, 0x58, 0x45, 0x44, 0x36, 0x34, 0x5f, 0x42, 0x49, 0x47, 0x10, 0x05, 0x12, 0x12,
	0x0a, 0x0e, 0x46, 0x49, 0x58, 0x45, 0x44, 0x36, 0x34, 0x5f, 0x4c, 0x49, 0x54, 0x54, 0x4c, 0x45,
	0x10, 0x06, 0x12, 0x14, 0x0a, 0x10, 0x52, 0x45, 0x51, 0x55, 0x49, 0x52, 0x45, 0x5f, 0x33, 0x32,
	0x5f, 0x42, 0x59, 0x54, 0x45, 0x53, 0x10, 0x07, 0x12, 0x14, 0x0a, 0x10, 0x52, 0x45, 0x51, 0x55,
	0x49, 0x52, 0x45, 0x5f, 0x36, 0x34, 0x5f, 0x42, 0x59, 0x54, 0x45, 0x53, 0x10, 0x08, 0x42, 0x22,
	0x5a, 0x20, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x2f, 0x69, 0x63, 0x73, 0x32, 0x33, 0x2f, 0x67, 0x6f, 0x3b, 0x69, 0x63, 0x73,
	0x32, 0x33, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_cosmos_ics23_v1_proofs_proto_rawDescOnce sync.Once
	file_cosmos_ics23_v1_proofs_proto_rawDescData = file_cosmos_ics23_v1_proofs_proto_rawDesc
)

func file_cosmos_ics23_v1_proofs_proto_rawDescGZIP() []byte {
	file_cosmos_ics23_v1_proofs_proto_rawDescOnce.Do(func() {
		file_cosmos_ics23_v1_proofs_proto_rawDescData = protoimpl.X.CompressGZIP(file_cosmos_ics23_v1_proofs_proto_rawDescData)
	})
	return file_cosmos_ics23_v1_proofs_proto_rawDescData
}

var file_cosmos_ics23_v1_proofs_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_cosmos_ics23_v1_proofs_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_cosmos_ics23_v1_proofs_proto_goTypes = []interface{}{
	(HashOp)(0),                         // 0: cosmos.ics23.v1.HashOp
	(LengthOp)(0),                       // 1: cosmos.ics23.v1.LengthOp
	(*ExistenceProof)(nil),              // 2: cosmos.ics23.v1.ExistenceProof
	(*NonExistenceProof)(nil),           // 3: cosmos.ics23.v1.NonExistenceProof
	(*CommitmentProof)(nil),             // 4: cosmos.ics23.v1.CommitmentProof
	(*LeafOp)(nil),                      // 5: cosmos.ics23.v1.LeafOp
	(*InnerOp)(nil),                     // 6: cosmos.ics23.v1.InnerOp
	(*ProofSpec)(nil),                   // 7: cosmos.ics23.v1.ProofSpec
	(*InnerSpec)(nil),                   // 8: cosmos.ics23.v1.InnerSpec
	(*BatchProof)(nil),                  // 9: cosmos.ics23.v1.BatchProof
	(*BatchEntry)(nil),                  // 10: cosmos.ics23.v1.BatchEntry
	(*CompressedBatchProof)(nil),        // 11: cosmos.ics23.v1.CompressedBatchProof
	(*CompressedBatchEntry)(nil),        // 12: cosmos.ics23.v1.CompressedBatchEntry
	(*CompressedExistenceProof)(nil),    // 13: cosmos.ics23.v1.CompressedExistenceProof
	(*CompressedNonExistenceProof)(nil), // 14: cosmos.ics23.v1.CompressedNonExistenceProof
}
var file_cosmos_ics23_v1_proofs_proto_depIdxs = []int32{
	5,  // 0: cosmos.ics23.v1.ExistenceProof.leaf:type_name -> cosmos.ics23.v1.LeafOp
	6,  // 1: cosmos.ics23.v1.ExistenceProof.path:type_name -> cosmos.ics23.v1.InnerOp
	2,  // 2: cosmos.ics23.v1.NonExistenceProof.left:type_name -> cosmos.ics23.v1.ExistenceProof
	2,  // 3: cosmos.ics23.v1.NonExistenceProof.right:type_name -> cosmos.ics23.v1.ExistenceProof
	2,  // 4: cosmos.ics23.v1.CommitmentProof.exist:type_name -> cosmos.ics23.v1.ExistenceProof
	3,  // 5: cosmos.ics23.v1.CommitmentProof.nonexist:type_name -> cosmos.ics23.v1.NonExistenceProof
	9,  // 6: cosmos.ics23.v1.CommitmentProof.batch:type_name -> cosmos.ics23.v1.BatchProof
	11, // 7: cosmos.ics23.v1.CommitmentProof.compressed:type_name -> cosmos.ics23.v1.CompressedBatchProof
	0,  // 8: cosmos.ics23.v1.LeafOp.hash:type_name -> cosmos.ics23.v1.HashOp
	0,  // 9: cosmos.ics23.v1.LeafOp.prehash_key:type_name -> cosmos.ics23.v1.HashOp
	0,  // 10: cosmos.ics23.v1.LeafOp.prehash_value:type_name -> cosmos.ics23.v1.HashOp
	1,  // 11: cosmos.ics23.v1.LeafOp.length:type_name -> cosmos.ics23.v1.LengthOp
	0,  // 12: cosmos.ics23.v1.InnerOp.hash:type_name -> cosmos.ics23.v1.HashOp
	5,  // 13: cosmos.ics23.v1.ProofSpec.leaf_spec:type_name -> cosmos.ics23.v1.LeafOp
	8,  // 14: cosmos.ics23.v1.ProofSpec.inner_spec:type_name -> cosmos.ics23.v1.InnerSpec
	0,  // 15: cosmos.ics23.v1.InnerSpec.hash:type_name -> cosmos.ics23.v1.HashOp
	10, // 16: cosmos.ics23.v1.BatchProof.entries:type_name -> cosmos.ics23.v1.BatchEntry
	2,  // 17: cosmos.ics23.v1.BatchEntry.exist:type_name -> cosmos.ics23.v1.ExistenceProof
	3,  // 18: cosmos.ics23.v1.BatchEntry.nonexist:type_name -> cosmos.ics23.v1.NonExistenceProof
	12, // 19: cosmos.ics23.v1.CompressedBatchProof.entries:type_name -> cosmos.ics23.v1.CompressedBatchEntry
	6,  // 20: cosmos.ics23.v1.CompressedBatchProof.lookup_inners:type_name -> cosmos.ics23.v1.InnerOp
	13, // 21: cosmos.ics23.v1.CompressedBatchEntry.exist:type_name -> cosmos.ics23.v1.CompressedExistenceProof
	14, // 22: cosmos.ics23.v1.CompressedBatchEntry.nonexist:type_name -> cosmos.ics23.v1.CompressedNonExistenceProof
	5,  // 23: cosmos.ics23.v1.CompressedExistenceProof.leaf:type_name -> cosmos.ics23.v1.LeafOp
	13, // 24: cosmos.ics23.v1.CompressedNonExistenceProof.left:type_name -> cosmos.ics23.v1.CompressedExistenceProof
	13, // 25: cosmos.ics23.v1.CompressedNonExistenceProof.right:type_name -> cosmos.ics23.v1.CompressedExistenceProof
	26, // [26:26] is the sub-list for method output_type
	26, // [26:26] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_cosmos_ics23_v1_proofs_proto_init() }
func file_cosmos_ics23_v1_proofs_proto_init() {
	if File_cosmos_ics23_v1_proofs_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_cosmos_ics23_v1_proofs_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExistenceProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NonExistenceProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitmentProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LeafOp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*InnerOp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ProofSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*InnerSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CompressedBatchProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CompressedBatchEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CompressedExistenceProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cosmos_ics23_v1_proofs_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CompressedNonExistenceProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_cosmos_ics23_v1_proofs_proto_msgTypes[2].OneofWrappers = []interface{}{
		(*CommitmentProof_Exist)(nil),
		(*CommitmentProof_Nonexist)(nil),
		(*CommitmentProof_Batch)(nil),
		(*CommitmentProof_Compressed)(nil),
	}
	file_cosmos_ics23_v1_proofs_proto_msgTypes[8].OneofWrappers = []interface{}{
		(*BatchEntry_Exist)(nil),
		(*BatchEntry_Nonexist)(nil),
	}
	file_cosmos_ics23_v1_proofs_proto_msgTypes[10].OneofWrappers = []interface{}{
		(*CompressedBatchEntry_Exist)(nil),
		(*CompressedBatchEntry_Nonexist)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_cosmos_ics23_v1_proofs_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_cosmos_ics23_v1_proofs_proto_goTypes,
		DependencyIndexes: file_cosmos_ics23_v1_proofs_proto_depIdxs,
		EnumInfos:         file_cosmos_ics23_v1_proofs_proto_enumTypes,
		MessageInfos:      file_cosmos_ics23_v1_proofs_proto_msgTypes,
	}.Build()
	File_cosmos_ics23_v1_proofs_proto = out.File
	file_cosmos_ics23_v1_proofs_proto_rawDesc = nil
	file_cosmos_ics23_v1_proofs_proto_goTypes = nil
	file_cosmos_ics23_v1_proofs_proto_depIdxs = nil
}
