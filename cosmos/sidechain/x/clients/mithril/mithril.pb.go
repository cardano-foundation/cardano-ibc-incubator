// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/clients/mithril/v1/mithril.proto

package mithril

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Protocol Message Part Key
type ProtocolMessagePartKey int32

const (
	// Invalid message part key
	PROTOCOL_MESSAGE_PART_KEY_UNSPECIFIED ProtocolMessagePartKey = 0
	// key "snapshot_digest"
	PROTOCOL_MESSAGE_PART_KEY_SNAPSHOT_DIGEST ProtocolMessagePartKey = 1
	// key "cardano_transactions_merkle_root"
	PROTOCOL_MESSAGE_PART_KEY_CARDANO_TRANSACTIONS_MERKLE_ROOT ProtocolMessagePartKey = 2
	// key "next_aggregate_verification_key"
	PROTOCOL_MESSAGE_PART_KEY_NEXT_AGGREGATE_VERIFICATION_KEY ProtocolMessagePartKey = 3
	// key "latest_immutable_file_number"
	PROTOCOL_MESSAGE_PART_KEY_LATEST_IMMUTABLE_FILE_NUMBER ProtocolMessagePartKey = 4
	// key "latest_block_number"
	PROTOCOL_MESSAGE_PART_KEY_LATEST_BLOCK_NUMBER ProtocolMessagePartKey = 5
)

var ProtocolMessagePartKey_name = map[int32]string{
	0: "PROTOCOL_MESSAGE_PART_KEY_UNSPECIFIED",
	1: "PROTOCOL_MESSAGE_PART_KEY_SNAPSHOT_DIGEST",
	2: "PROTOCOL_MESSAGE_PART_KEY_CARDANO_TRANSACTIONS_MERKLE_ROOT",
	3: "PROTOCOL_MESSAGE_PART_KEY_NEXT_AGGREGATE_VERIFICATION_KEY",
	4: "PROTOCOL_MESSAGE_PART_KEY_LATEST_IMMUTABLE_FILE_NUMBER",
	5: "PROTOCOL_MESSAGE_PART_KEY_LATEST_BLOCK_NUMBER",
}

var ProtocolMessagePartKey_value = map[string]int32{
	"PROTOCOL_MESSAGE_PART_KEY_UNSPECIFIED":                      0,
	"PROTOCOL_MESSAGE_PART_KEY_SNAPSHOT_DIGEST":                  1,
	"PROTOCOL_MESSAGE_PART_KEY_CARDANO_TRANSACTIONS_MERKLE_ROOT": 2,
	"PROTOCOL_MESSAGE_PART_KEY_NEXT_AGGREGATE_VERIFICATION_KEY":  3,
	"PROTOCOL_MESSAGE_PART_KEY_LATEST_IMMUTABLE_FILE_NUMBER":     4,
	"PROTOCOL_MESSAGE_PART_KEY_LATEST_BLOCK_NUMBER":              5,
}

func (x ProtocolMessagePartKey) String() string {
	return proto.EnumName(ProtocolMessagePartKey_name, int32(x))
}

func (ProtocolMessagePartKey) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{0}
}

// Currently, the height of the certificate corresponds to the immutable file number in Cardano node
// However, it is possible to have two certificates on the same immutable file.
// This needs to be fixed in the future by using something unique like block height.
type Height struct {
	// the revision that the client is currently on
	RevisionNumber uint64 `protobuf:"varint,1,opt,name=revision_number,json=revisionNumber,proto3" json:"revision_number,omitempty"`
	// the height within the given revision
	RevisionHeight uint64 `protobuf:"varint,2,opt,name=revision_height,json=revisionHeight,proto3" json:"revision_height,omitempty"`
}

func (m *Height) Reset()      { *m = Height{} }
func (*Height) ProtoMessage() {}
func (*Height) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{0}
}
func (m *Height) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Height) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Height.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Height) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Height.Merge(m, src)
}
func (m *Height) XXX_Size() int {
	return m.Size()
}
func (m *Height) XXX_DiscardUnknown() {
	xxx_messageInfo_Height.DiscardUnknown(m)
}

var xxx_messageInfo_Height proto.InternalMessageInfo

// MithrilClientState represents the client state in the Mithril system.
// Currently, this message includes protocol parameters.
// However, these protocol parameters might be removed in the future,
// as they can change across different epochs in Mithril.
type ClientState struct {
	// Chain id
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Latest height the client was updated to
	LatestHeight *Height `protobuf:"bytes,2,opt,name=latest_height,json=latestHeight,proto3" json:"latest_height,omitempty"`
	// Block height when the client was frozen due to a misbehaviour
	FrozenHeight *Height `protobuf:"bytes,3,opt,name=frozen_height,json=frozenHeight,proto3" json:"frozen_height,omitempty"`
	// Epoch number of current chain state
	CurrentEpoch       uint64                     `protobuf:"varint,4,opt,name=current_epoch,json=currentEpoch,proto3" json:"current_epoch,omitempty"`
	TrustingPeriod     time.Duration              `protobuf:"bytes,5,opt,name=trusting_period,json=trustingPeriod,proto3,stdduration" json:"trusting_period"`
	ProtocolParameters *MithrilProtocolParameters `protobuf:"bytes,6,opt,name=protocol_parameters,json=protocolParameters,proto3" json:"protocol_parameters,omitempty"`
	// Path at which next upgraded client will be committed.
	UpgradePath []string `protobuf:"bytes,7,rep,name=upgrade_path,json=upgradePath,proto3" json:"upgrade_path,omitempty"`
	// HostState NFT identification on the Cardano chain.
	//
	// The HostState UTxO is the single source of truth for Cardano IBC state and is
	// uniquely identified by this NFT. The light client uses this to locate the
	// HostState output inside the certified transaction body and to extract the
	// `ibc_state_root` from its inline datum.
	HostStateNftPolicyId  []byte `protobuf:"bytes,8,opt,name=host_state_nft_policy_id,json=hostStateNftPolicyId,proto3" json:"host_state_nft_policy_id,omitempty"`
	HostStateNftTokenName []byte `protobuf:"bytes,9,opt,name=host_state_nft_token_name,json=hostStateNftTokenName,proto3" json:"host_state_nft_token_name,omitempty"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{1}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

// MithrilConsensusState represents the consensus state in the Mithril system.
// This message stores the latest transaction snapshot hash and the first certificate hash of the latest epoch.
// These are used to verify the latest transaction snapshot.
type ConsensusState struct {
	Timestamp                uint64              `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	FirstCertHashLatestEpoch *MithrilCertificate `protobuf:"bytes,2,opt,name=first_cert_hash_latest_epoch,json=firstCertHashLatestEpoch,proto3" json:"first_cert_hash_latest_epoch,omitempty"`
	LatestCertHashTxSnapshot string              `protobuf:"bytes,3,opt,name=latest_cert_hash_tx_snapshot,json=latestCertHashTxSnapshot,proto3" json:"latest_cert_hash_tx_snapshot,omitempty"`
	// Authenticated commitment root for Cardano IBC state at this height.
	//
	// This is the exact 32-byte `ibc_state_root` extracted from the on-chain
	// HostState datum whose creating transaction is proven to be included in the
	// Mithril-certified transaction snapshot for this height.
	IbcStateRoot []byte `protobuf:"bytes,4,opt,name=ibc_state_root,json=ibcStateRoot,proto3" json:"ibc_state_root,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{2}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

// Misbehavior represents a conflict between two headers.
type Misbehaviour struct {
	// ClientID is deprecated
	ClientId       string         `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"` // Deprecated: Do not use.
	MithrilHeader1 *MithrilHeader `protobuf:"bytes,2,opt,name=mithril_header_1,json=mithrilHeader1,proto3" json:"mithril_header_1,omitempty"`
	MithrilHeader2 *MithrilHeader `protobuf:"bytes,3,opt,name=mithril_header_2,json=mithrilHeader2,proto3" json:"mithril_header_2,omitempty"`
}

func (m *Misbehaviour) Reset()         { *m = Misbehaviour{} }
func (m *Misbehaviour) String() string { return proto.CompactTextString(m) }
func (*Misbehaviour) ProtoMessage()    {}
func (*Misbehaviour) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{3}
}
func (m *Misbehaviour) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Misbehaviour) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Misbehaviour.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Misbehaviour) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Misbehaviour.Merge(m, src)
}
func (m *Misbehaviour) XXX_Size() int {
	return m.Size()
}
func (m *Misbehaviour) XXX_DiscardUnknown() {
	xxx_messageInfo_Misbehaviour.DiscardUnknown(m)
}

var xxx_messageInfo_Misbehaviour proto.InternalMessageInfo

// Mithril Header
type MithrilHeader struct {
	MithrilStakeDistribution            *MithrilStakeDistribution   `protobuf:"bytes,1,opt,name=mithril_stake_distribution,json=mithrilStakeDistribution,proto3" json:"mithril_stake_distribution,omitempty"`
	MithrilStakeDistributionCertificate *MithrilCertificate         `protobuf:"bytes,2,opt,name=mithril_stake_distribution_certificate,json=mithrilStakeDistributionCertificate,proto3" json:"mithril_stake_distribution_certificate,omitempty"`
	TransactionSnapshot                 *CardanoTransactionSnapshot `protobuf:"bytes,3,opt,name=transaction_snapshot,json=transactionSnapshot,proto3" json:"transaction_snapshot,omitempty"`
	TransactionSnapshotCertificate      *MithrilCertificate         `protobuf:"bytes,4,opt,name=transaction_snapshot_certificate,json=transactionSnapshotCertificate,proto3" json:"transaction_snapshot_certificate,omitempty"`
	// Optional chain of previous Mithril stake distribution certificates.
	//
	// The Mithril stake distribution certificate of epoch N links to the previous epoch’s
	// certificate via `previous_hash`. If the light client is updated after missing one or
	// more epochs, it must be able to verify and store those missing certificates to keep
	// the certificate chain verifiable.
	//
	// This list should include the certificates for the epochs immediately preceding
	// `mithril_stake_distribution_certificate` (field 2). It MUST NOT include the current
	// epoch’s certificate (field 2). The verifier may ignore extra entries.
	PreviousMithrilStakeDistributionCertificates []*MithrilCertificate `protobuf:"bytes,9,rep,name=previous_mithril_stake_distribution_certificates,json=previousMithrilStakeDistributionCertificates,proto3" json:"previous_mithril_stake_distribution_certificates,omitempty"`
	// HostState commitment evidence for this height.
	//
	// The goal is to let the counterparty verify:
	// 1) a specific transaction is included in the Mithril-certified transaction set,
	// 2) that transaction creates the HostState UTxO (identified by the HostState NFT),
	// 3) the inline datum on that output commits to `ibc_state_root`, and
	// 4) that root is used for ICS-23 proof verification at this height.
	HostStateTxHash        string `protobuf:"bytes,5,opt,name=host_state_tx_hash,json=hostStateTxHash,proto3" json:"host_state_tx_hash,omitempty"`
	HostStateTxBodyCbor    []byte `protobuf:"bytes,6,opt,name=host_state_tx_body_cbor,json=hostStateTxBodyCbor,proto3" json:"host_state_tx_body_cbor,omitempty"`
	HostStateTxOutputIndex uint32 `protobuf:"varint,7,opt,name=host_state_tx_output_index,json=hostStateTxOutputIndex,proto3" json:"host_state_tx_output_index,omitempty"`
	HostStateTxProof       []byte `protobuf:"bytes,8,opt,name=host_state_tx_proof,json=hostStateTxProof,proto3" json:"host_state_tx_proof,omitempty"`
}

func (m *MithrilHeader) Reset()         { *m = MithrilHeader{} }
func (m *MithrilHeader) String() string { return proto.CompactTextString(m) }
func (*MithrilHeader) ProtoMessage()    {}
func (*MithrilHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{4}
}
func (m *MithrilHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilHeader.Merge(m, src)
}
func (m *MithrilHeader) XXX_Size() int {
	return m.Size()
}
func (m *MithrilHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilHeader.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilHeader proto.InternalMessageInfo

// Mithril Stake Distribution
type MithrilStakeDistribution struct {
	Epoch             uint64                     `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	SignersWithStake  []*SignerWithStake         `protobuf:"bytes,2,rep,name=signers_with_stake,json=signersWithStake,proto3" json:"signers_with_stake,omitempty"`
	Hash              string                     `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	CertificateHash   string                     `protobuf:"bytes,4,opt,name=certificate_hash,json=certificateHash,proto3" json:"certificate_hash,omitempty"`
	CreatedAt         uint64                     `protobuf:"varint,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	ProtocolParameter *MithrilProtocolParameters `protobuf:"bytes,6,opt,name=protocol_parameter,json=protocolParameter,proto3" json:"protocol_parameter,omitempty"`
}

func (m *MithrilStakeDistribution) Reset()         { *m = MithrilStakeDistribution{} }
func (m *MithrilStakeDistribution) String() string { return proto.CompactTextString(m) }
func (*MithrilStakeDistribution) ProtoMessage()    {}
func (*MithrilStakeDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{5}
}
func (m *MithrilStakeDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilStakeDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilStakeDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilStakeDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilStakeDistribution.Merge(m, src)
}
func (m *MithrilStakeDistribution) XXX_Size() int {
	return m.Size()
}
func (m *MithrilStakeDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilStakeDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilStakeDistribution proto.InternalMessageInfo

// Cardano Transaction Snapshot
type CardanoTransactionSnapshot struct {
	MerkleRoot      string `protobuf:"bytes,1,opt,name=merkle_root,json=merkleRoot,proto3" json:"merkle_root,omitempty"`
	Epoch           uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	BlockNumber     uint64 `protobuf:"varint,3,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	Hash            string `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
	CertificateHash string `protobuf:"bytes,5,opt,name=certificate_hash,json=certificateHash,proto3" json:"certificate_hash,omitempty"`
	CreatedAt       string `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (m *CardanoTransactionSnapshot) Reset()         { *m = CardanoTransactionSnapshot{} }
func (m *CardanoTransactionSnapshot) String() string { return proto.CompactTextString(m) }
func (*CardanoTransactionSnapshot) ProtoMessage()    {}
func (*CardanoTransactionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{6}
}
func (m *CardanoTransactionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardanoTransactionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardanoTransactionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardanoTransactionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardanoTransactionSnapshot.Merge(m, src)
}
func (m *CardanoTransactionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CardanoTransactionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CardanoTransactionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CardanoTransactionSnapshot proto.InternalMessageInfo

// Mithril Certificate
type MithrilCertificate struct {
	Hash                     string               `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	PreviousHash             string               `protobuf:"bytes,2,opt,name=previous_hash,json=previousHash,proto3" json:"previous_hash,omitempty"`
	Epoch                    uint64               `protobuf:"varint,3,opt,name=epoch,proto3" json:"epoch,omitempty"`
	SignedEntityType         *SignedEntityType    `protobuf:"bytes,4,opt,name=signed_entity_type,json=signedEntityType,proto3" json:"signed_entity_type,omitempty"`
	Metadata                 *CertificateMetadata `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
	ProtocolMessage          *ProtocolMessage     `protobuf:"bytes,6,opt,name=protocol_message,json=protocolMessage,proto3" json:"protocol_message,omitempty"`
	SignedMessage            string               `protobuf:"bytes,7,opt,name=signed_message,json=signedMessage,proto3" json:"signed_message,omitempty"`
	AggregateVerificationKey string               `protobuf:"bytes,8,opt,name=aggregate_verification_key,json=aggregateVerificationKey,proto3" json:"aggregate_verification_key,omitempty"`
	MultiSignature           string               `protobuf:"bytes,9,opt,name=multi_signature,json=multiSignature,proto3" json:"multi_signature,omitempty"`
	GenesisSignature         string               `protobuf:"bytes,10,opt,name=genesis_signature,json=genesisSignature,proto3" json:"genesis_signature,omitempty"`
}

func (m *MithrilCertificate) Reset()         { *m = MithrilCertificate{} }
func (m *MithrilCertificate) String() string { return proto.CompactTextString(m) }
func (*MithrilCertificate) ProtoMessage()    {}
func (*MithrilCertificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{7}
}
func (m *MithrilCertificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilCertificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilCertificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilCertificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilCertificate.Merge(m, src)
}
func (m *MithrilCertificate) XXX_Size() int {
	return m.Size()
}
func (m *MithrilCertificate) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilCertificate.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilCertificate proto.InternalMessageInfo

// Certificate Metadata
type CertificateMetadata struct {
	Network            string                     `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	ProtocolVersion    string                     `protobuf:"bytes,2,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	ProtocolParameters *MithrilProtocolParameters `protobuf:"bytes,3,opt,name=protocol_parameters,json=protocolParameters,proto3" json:"protocol_parameters,omitempty"`
	InitiatedAt        string                     `protobuf:"bytes,4,opt,name=initiated_at,json=initiatedAt,proto3" json:"initiated_at,omitempty"`
	SealedAt           string                     `protobuf:"bytes,5,opt,name=sealed_at,json=sealedAt,proto3" json:"sealed_at,omitempty"`
	Signers            []*SignerWithStake         `protobuf:"bytes,6,rep,name=signers,proto3" json:"signers,omitempty"`
}

func (m *CertificateMetadata) Reset()         { *m = CertificateMetadata{} }
func (m *CertificateMetadata) String() string { return proto.CompactTextString(m) }
func (*CertificateMetadata) ProtoMessage()    {}
func (*CertificateMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{8}
}
func (m *CertificateMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertificateMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertificateMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateMetadata.Merge(m, src)
}
func (m *CertificateMetadata) XXX_Size() int {
	return m.Size()
}
func (m *CertificateMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateMetadata proto.InternalMessageInfo

// Signer With Stake
type SignerWithStake struct {
	PartyId string `protobuf:"bytes,1,opt,name=party_id,json=partyId,proto3" json:"party_id,omitempty"`
	Stake   uint64 `protobuf:"varint,2,opt,name=stake,proto3" json:"stake,omitempty"`
}

func (m *SignerWithStake) Reset()         { *m = SignerWithStake{} }
func (m *SignerWithStake) String() string { return proto.CompactTextString(m) }
func (*SignerWithStake) ProtoMessage()    {}
func (*SignerWithStake) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{9}
}
func (m *SignerWithStake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignerWithStake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignerWithStake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignerWithStake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignerWithStake.Merge(m, src)
}
func (m *SignerWithStake) XXX_Size() int {
	return m.Size()
}
func (m *SignerWithStake) XXX_DiscardUnknown() {
	xxx_messageInfo_SignerWithStake.DiscardUnknown(m)
}

var xxx_messageInfo_SignerWithStake proto.InternalMessageInfo

// Protocol Message
type ProtocolMessage struct {
	MessageParts []*MessagePart `protobuf:"bytes,1,rep,name=message_parts,json=messageParts,proto3" json:"message_parts,omitempty"`
}

func (m *ProtocolMessage) Reset()         { *m = ProtocolMessage{} }
func (m *ProtocolMessage) String() string { return proto.CompactTextString(m) }
func (*ProtocolMessage) ProtoMessage()    {}
func (*ProtocolMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{10}
}
func (m *ProtocolMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolMessage.Merge(m, src)
}
func (m *ProtocolMessage) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolMessage proto.InternalMessageInfo

// Message Part
type MessagePart struct {
	ProtocolMessagePartKey   ProtocolMessagePartKey `protobuf:"varint,1,opt,name=protocol_message_part_key,json=protocolMessagePartKey,proto3,enum=ibc.clients.mithril.v1.ProtocolMessagePartKey" json:"protocol_message_part_key,omitempty"`
	ProtocolMessagePartValue string                 `protobuf:"bytes,2,opt,name=protocol_message_part_value,json=protocolMessagePartValue,proto3" json:"protocol_message_part_value,omitempty"`
}

func (m *MessagePart) Reset()         { *m = MessagePart{} }
func (m *MessagePart) String() string { return proto.CompactTextString(m) }
func (*MessagePart) ProtoMessage()    {}
func (*MessagePart) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{11}
}
func (m *MessagePart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessagePart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessagePart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessagePart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessagePart.Merge(m, src)
}
func (m *MessagePart) XXX_Size() int {
	return m.Size()
}
func (m *MessagePart) XXX_DiscardUnknown() {
	xxx_messageInfo_MessagePart.DiscardUnknown(m)
}

var xxx_messageInfo_MessagePart proto.InternalMessageInfo

// Mithril Protocol Parameters
type MithrilProtocolParameters struct {
	// Quorum parameter
	K uint64 `protobuf:"varint,1,opt,name=k,proto3" json:"k,omitempty"`
	// Security parameter (number of lotteries)
	M uint64 `protobuf:"varint,2,opt,name=m,proto3" json:"m,omitempty"`
	// f in phi(w) = 1 - (1 - f)^w, where w is the stake of a participant
	PhiF Fraction `protobuf:"bytes,3,opt,name=phi_f,json=phiF,proto3" json:"phi_f"`
}

func (m *MithrilProtocolParameters) Reset()         { *m = MithrilProtocolParameters{} }
func (m *MithrilProtocolParameters) String() string { return proto.CompactTextString(m) }
func (*MithrilProtocolParameters) ProtoMessage()    {}
func (*MithrilProtocolParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{12}
}
func (m *MithrilProtocolParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilProtocolParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilProtocolParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilProtocolParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilProtocolParameters.Merge(m, src)
}
func (m *MithrilProtocolParameters) XXX_Size() int {
	return m.Size()
}
func (m *MithrilProtocolParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilProtocolParameters.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilProtocolParameters proto.InternalMessageInfo

// ProtocolGenesisSignature wraps a cryptographic signature.
type ProtocolGenesisSignature struct {
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *ProtocolGenesisSignature) Reset()         { *m = ProtocolGenesisSignature{} }
func (m *ProtocolGenesisSignature) String() string { return proto.CompactTextString(m) }
func (*ProtocolGenesisSignature) ProtoMessage()    {}
func (*ProtocolGenesisSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{13}
}
func (m *ProtocolGenesisSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolGenesisSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolGenesisSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolGenesisSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolGenesisSignature.Merge(m, src)
}
func (m *ProtocolGenesisSignature) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolGenesisSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolGenesisSignature.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolGenesisSignature proto.InternalMessageInfo

func (m *ProtocolGenesisSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// An entity type associated with the signature.
type SignedEntityType struct {
	// MithrilStakeDistribution(epoch), CardanoStakeDistribution(epoch), CardanoImmutableFilesFull(CardanoDbBeacon), CardanoTransactions(CardanoDbBeacon)
	//
	// Types that are valid to be assigned to Entity:
	//
	//	*SignedEntityType_MithrilStakeDistribution
	//	*SignedEntityType_CardanoStakeDistribution
	//	*SignedEntityType_CardanoImmutableFilesFull
	//	*SignedEntityType_CardanoTransactions
	Entity isSignedEntityType_Entity `protobuf_oneof:"entity"`
}

func (m *SignedEntityType) Reset()         { *m = SignedEntityType{} }
func (m *SignedEntityType) String() string { return proto.CompactTextString(m) }
func (*SignedEntityType) ProtoMessage()    {}
func (*SignedEntityType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{14}
}
func (m *SignedEntityType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedEntityType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedEntityType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedEntityType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedEntityType.Merge(m, src)
}
func (m *SignedEntityType) XXX_Size() int {
	return m.Size()
}
func (m *SignedEntityType) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedEntityType.DiscardUnknown(m)
}

var xxx_messageInfo_SignedEntityType proto.InternalMessageInfo

type isSignedEntityType_Entity interface {
	isSignedEntityType_Entity()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SignedEntityType_MithrilStakeDistribution struct {
	MithrilStakeDistribution *MithrilStakeDistribution `protobuf:"bytes,1,opt,name=mithril_stake_distribution,json=mithrilStakeDistribution,proto3,oneof" json:"mithril_stake_distribution,omitempty"`
}
type SignedEntityType_CardanoStakeDistribution struct {
	CardanoStakeDistribution *CardanoStakeDistribution `protobuf:"bytes,2,opt,name=cardano_stake_distribution,json=cardanoStakeDistribution,proto3,oneof" json:"cardano_stake_distribution,omitempty"`
}
type SignedEntityType_CardanoImmutableFilesFull struct {
	CardanoImmutableFilesFull *CardanoImmutableFilesFull `protobuf:"bytes,3,opt,name=cardano_immutable_files_full,json=cardanoImmutableFilesFull,proto3,oneof" json:"cardano_immutable_files_full,omitempty"`
}
type SignedEntityType_CardanoTransactions struct {
	CardanoTransactions *CardanoTransactions `protobuf:"bytes,4,opt,name=cardano_transactions,json=cardanoTransactions,proto3,oneof" json:"cardano_transactions,omitempty"`
}

func (*SignedEntityType_MithrilStakeDistribution) isSignedEntityType_Entity()  {}
func (*SignedEntityType_CardanoStakeDistribution) isSignedEntityType_Entity()  {}
func (*SignedEntityType_CardanoImmutableFilesFull) isSignedEntityType_Entity() {}
func (*SignedEntityType_CardanoTransactions) isSignedEntityType_Entity()       {}

func (m *SignedEntityType) GetEntity() isSignedEntityType_Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *SignedEntityType) GetMithrilStakeDistribution() *MithrilStakeDistribution {
	if x, ok := m.GetEntity().(*SignedEntityType_MithrilStakeDistribution); ok {
		return x.MithrilStakeDistribution
	}
	return nil
}

func (m *SignedEntityType) GetCardanoStakeDistribution() *CardanoStakeDistribution {
	if x, ok := m.GetEntity().(*SignedEntityType_CardanoStakeDistribution); ok {
		return x.CardanoStakeDistribution
	}
	return nil
}

func (m *SignedEntityType) GetCardanoImmutableFilesFull() *CardanoImmutableFilesFull {
	if x, ok := m.GetEntity().(*SignedEntityType_CardanoImmutableFilesFull); ok {
		return x.CardanoImmutableFilesFull
	}
	return nil
}

func (m *SignedEntityType) GetCardanoTransactions() *CardanoTransactions {
	if x, ok := m.GetEntity().(*SignedEntityType_CardanoTransactions); ok {
		return x.CardanoTransactions
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SignedEntityType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SignedEntityType_MithrilStakeDistribution)(nil),
		(*SignedEntityType_CardanoStakeDistribution)(nil),
		(*SignedEntityType_CardanoImmutableFilesFull)(nil),
		(*SignedEntityType_CardanoTransactions)(nil),
	}
}

// Cardano stake distribution
type CardanoStakeDistribution struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *CardanoStakeDistribution) Reset()         { *m = CardanoStakeDistribution{} }
func (m *CardanoStakeDistribution) String() string { return proto.CompactTextString(m) }
func (*CardanoStakeDistribution) ProtoMessage()    {}
func (*CardanoStakeDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{15}
}
func (m *CardanoStakeDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardanoStakeDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardanoStakeDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardanoStakeDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardanoStakeDistribution.Merge(m, src)
}
func (m *CardanoStakeDistribution) XXX_Size() int {
	return m.Size()
}
func (m *CardanoStakeDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_CardanoStakeDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_CardanoStakeDistribution proto.InternalMessageInfo

func (m *CardanoStakeDistribution) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

// Cardano immutable files full
type CardanoImmutableFilesFull struct {
	Beacon *CardanoDbBeacon `protobuf:"bytes,1,opt,name=beacon,proto3" json:"beacon,omitempty"`
}

func (m *CardanoImmutableFilesFull) Reset()         { *m = CardanoImmutableFilesFull{} }
func (m *CardanoImmutableFilesFull) String() string { return proto.CompactTextString(m) }
func (*CardanoImmutableFilesFull) ProtoMessage()    {}
func (*CardanoImmutableFilesFull) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{16}
}
func (m *CardanoImmutableFilesFull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardanoImmutableFilesFull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardanoImmutableFilesFull.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardanoImmutableFilesFull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardanoImmutableFilesFull.Merge(m, src)
}
func (m *CardanoImmutableFilesFull) XXX_Size() int {
	return m.Size()
}
func (m *CardanoImmutableFilesFull) XXX_DiscardUnknown() {
	xxx_messageInfo_CardanoImmutableFilesFull.DiscardUnknown(m)
}

var xxx_messageInfo_CardanoImmutableFilesFull proto.InternalMessageInfo

func (m *CardanoImmutableFilesFull) GetBeacon() *CardanoDbBeacon {
	if m != nil {
		return m.Beacon
	}
	return nil
}

// Cardano transactions
type CardanoTransactions struct {
	Epoch       uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	BlockNumber uint64 `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
}

func (m *CardanoTransactions) Reset()         { *m = CardanoTransactions{} }
func (m *CardanoTransactions) String() string { return proto.CompactTextString(m) }
func (*CardanoTransactions) ProtoMessage()    {}
func (*CardanoTransactions) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{17}
}
func (m *CardanoTransactions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardanoTransactions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardanoTransactions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardanoTransactions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardanoTransactions.Merge(m, src)
}
func (m *CardanoTransactions) XXX_Size() int {
	return m.Size()
}
func (m *CardanoTransactions) XXX_DiscardUnknown() {
	xxx_messageInfo_CardanoTransactions.DiscardUnknown(m)
}

var xxx_messageInfo_CardanoTransactions proto.InternalMessageInfo

func (m *CardanoTransactions) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *CardanoTransactions) GetBlockNumber() uint64 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

// Cardano db beacon
type CardanoDbBeacon struct {
	Network             string `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Epoch               uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	ImmutableFileNumber uint64 `protobuf:"varint,3,opt,name=immutable_file_number,json=immutableFileNumber,proto3" json:"immutable_file_number,omitempty"`
}

func (m *CardanoDbBeacon) Reset()         { *m = CardanoDbBeacon{} }
func (m *CardanoDbBeacon) String() string { return proto.CompactTextString(m) }
func (*CardanoDbBeacon) ProtoMessage()    {}
func (*CardanoDbBeacon) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{18}
}
func (m *CardanoDbBeacon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardanoDbBeacon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardanoDbBeacon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardanoDbBeacon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardanoDbBeacon.Merge(m, src)
}
func (m *CardanoDbBeacon) XXX_Size() int {
	return m.Size()
}
func (m *CardanoDbBeacon) XXX_DiscardUnknown() {
	xxx_messageInfo_CardanoDbBeacon.DiscardUnknown(m)
}

var xxx_messageInfo_CardanoDbBeacon proto.InternalMessageInfo

func (m *CardanoDbBeacon) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *CardanoDbBeacon) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *CardanoDbBeacon) GetImmutableFileNumber() uint64 {
	if m != nil {
		return m.ImmutableFileNumber
	}
	return 0
}

// Fraction defines the protobuf message type for tmmath.Fraction that only
// supports positive values.
type Fraction struct {
	Numerator   uint64 `protobuf:"varint,1,opt,name=numerator,proto3" json:"numerator,omitempty"`
	Denominator uint64 `protobuf:"varint,2,opt,name=denominator,proto3" json:"denominator,omitempty"`
}

func (m *Fraction) Reset()         { *m = Fraction{} }
func (m *Fraction) String() string { return proto.CompactTextString(m) }
func (*Fraction) ProtoMessage()    {}
func (*Fraction) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{19}
}
func (m *Fraction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fraction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fraction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fraction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fraction.Merge(m, src)
}
func (m *Fraction) XXX_Size() int {
	return m.Size()
}
func (m *Fraction) XXX_DiscardUnknown() {
	xxx_messageInfo_Fraction.DiscardUnknown(m)
}

var xxx_messageInfo_Fraction proto.InternalMessageInfo

func (m *Fraction) GetNumerator() uint64 {
	if m != nil {
		return m.Numerator
	}
	return 0
}

func (m *Fraction) GetDenominator() uint64 {
	if m != nil {
		return m.Denominator
	}
	return 0
}

func init() {
	proto.RegisterEnum("ibc.clients.mithril.v1.ProtocolMessagePartKey", ProtocolMessagePartKey_name, ProtocolMessagePartKey_value)
	proto.RegisterType((*Height)(nil), "ibc.clients.mithril.v1.Height")
	proto.RegisterType((*ClientState)(nil), "ibc.clients.mithril.v1.ClientState")
	proto.RegisterType((*ConsensusState)(nil), "ibc.clients.mithril.v1.ConsensusState")
	proto.RegisterType((*Misbehaviour)(nil), "ibc.clients.mithril.v1.Misbehaviour")
	proto.RegisterType((*MithrilHeader)(nil), "ibc.clients.mithril.v1.MithrilHeader")
	proto.RegisterType((*MithrilStakeDistribution)(nil), "ibc.clients.mithril.v1.MithrilStakeDistribution")
	proto.RegisterType((*CardanoTransactionSnapshot)(nil), "ibc.clients.mithril.v1.CardanoTransactionSnapshot")
	proto.RegisterType((*MithrilCertificate)(nil), "ibc.clients.mithril.v1.MithrilCertificate")
	proto.RegisterType((*CertificateMetadata)(nil), "ibc.clients.mithril.v1.CertificateMetadata")
	proto.RegisterType((*SignerWithStake)(nil), "ibc.clients.mithril.v1.SignerWithStake")
	proto.RegisterType((*ProtocolMessage)(nil), "ibc.clients.mithril.v1.ProtocolMessage")
	proto.RegisterType((*MessagePart)(nil), "ibc.clients.mithril.v1.MessagePart")
	proto.RegisterType((*MithrilProtocolParameters)(nil), "ibc.clients.mithril.v1.MithrilProtocolParameters")
	proto.RegisterType((*ProtocolGenesisSignature)(nil), "ibc.clients.mithril.v1.ProtocolGenesisSignature")
	proto.RegisterType((*SignedEntityType)(nil), "ibc.clients.mithril.v1.SignedEntityType")
	proto.RegisterType((*CardanoStakeDistribution)(nil), "ibc.clients.mithril.v1.CardanoStakeDistribution")
	proto.RegisterType((*CardanoImmutableFilesFull)(nil), "ibc.clients.mithril.v1.CardanoImmutableFilesFull")
	proto.RegisterType((*CardanoTransactions)(nil), "ibc.clients.mithril.v1.CardanoTransactions")
	proto.RegisterType((*CardanoDbBeacon)(nil), "ibc.clients.mithril.v1.CardanoDbBeacon")
	proto.RegisterType((*Fraction)(nil), "ibc.clients.mithril.v1.Fraction")
}

func init() {
	proto.RegisterFile("ibc/clients/mithril/v1/mithril.proto", fileDescriptor_4410ce5523531b7b)
}

var fileDescriptor_4410ce5523531b7b = []byte{
	// 1968 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xe7, 0x52, 0xb4, 0x24, 0x3e, 0x52, 0x12, 0x33, 0x72, 0xdc, 0x95, 0xec, 0x52, 0x8a, 0x1c,
	0xd7, 0x76, 0x5c, 0x4b, 0x96, 0xda, 0x06, 0xa9, 0xdb, 0xa4, 0x20, 0x29, 0x4a, 0x62, 0x2d, 0x7e,
	0x60, 0x48, 0xbb, 0x1f, 0x28, 0x30, 0x59, 0xee, 0x0e, 0xc9, 0xa9, 0xb8, 0x1f, 0xd8, 0x9d, 0x55,
	0xc4, 0x5c, 0x7a, 0x2b, 0x72, 0x2c, 0x7a, 0x4a, 0x6f, 0x01, 0xda, 0x7f, 0xa3, 0xd7, 0x36, 0x97,
	0x02, 0x39, 0x06, 0x3d, 0xa4, 0x85, 0x0d, 0xf4, 0xdf, 0x68, 0xb1, 0xb3, 0xb3, 0xe4, 0x92, 0xe2,
	0x5a, 0xb6, 0xd1, 0xdc, 0x38, 0xef, 0x63, 0x7e, 0xf3, 0x7e, 0xf3, 0xde, 0x9b, 0xb7, 0x84, 0x77,
	0x59, 0x57, 0xdf, 0xd3, 0x87, 0x8c, 0x5a, 0xdc, 0xdb, 0x33, 0x19, 0x1f, 0xb8, 0x6c, 0xb8, 0x77,
	0xbe, 0x1f, 0xfd, 0xdc, 0x75, 0x5c, 0x9b, 0xdb, 0xe8, 0x06, 0xeb, 0xea, 0xbb, 0xd2, 0x6a, 0x37,
	0x52, 0x9d, 0xef, 0x6f, 0x5e, 0xef, 0xdb, 0x7d, 0x5b, 0x98, 0xec, 0x05, 0xbf, 0x42, 0xeb, 0xcd,
	0x62, 0xdf, 0xb6, 0xfb, 0x43, 0xba, 0x27, 0x56, 0x5d, 0xbf, 0xb7, 0x67, 0xf8, 0xae, 0xc6, 0x99,
	0x6d, 0x85, 0xfa, 0x1d, 0x03, 0x16, 0x4f, 0x28, 0xeb, 0x0f, 0x38, 0xba, 0x0b, 0x6b, 0x2e, 0x3d,
	0x67, 0x1e, 0xb3, 0x2d, 0x62, 0xf9, 0x66, 0x97, 0xba, 0xaa, 0xb2, 0xad, 0xdc, 0xcb, 0xe0, 0xd5,
	0x48, 0xdc, 0x10, 0xd2, 0x29, 0xc3, 0x81, 0xf0, 0x55, 0xd3, 0xd3, 0x86, 0xe1, 0x8e, 0x8f, 0x97,
	0x3f, 0xfb, 0x62, 0x2b, 0xf5, 0xf9, 0x17, 0x5b, 0xa9, 0x9d, 0xbf, 0x64, 0x20, 0x57, 0x11, 0x47,
	0x6e, 0x73, 0x8d, 0x53, 0xb4, 0x01, 0xcb, 0xfa, 0x40, 0x63, 0x16, 0x61, 0x86, 0x00, 0xc9, 0xe2,
	0x25, 0xb1, 0xae, 0x19, 0xa8, 0x02, 0x2b, 0x43, 0x8d, 0x53, 0x8f, 0xc7, 0xf7, 0xce, 0x1d, 0x14,
	0x77, 0xe7, 0x87, 0xbd, 0x1b, 0x62, 0xe1, 0x7c, 0xe8, 0x24, 0x63, 0xa9, 0xc0, 0x4a, 0xcf, 0xb5,
	0x3f, 0xa5, 0xe3, 0x03, 0x2e, 0xbc, 0xda, 0x26, 0xa1, 0x93, 0xdc, 0xe4, 0x36, 0xac, 0xe8, 0xbe,
	0xeb, 0x52, 0x8b, 0x13, 0xea, 0xd8, 0xfa, 0x40, 0xcd, 0x88, 0x28, 0xf3, 0x52, 0x58, 0x0d, 0x64,
	0xe8, 0x14, 0xd6, 0xb8, 0xeb, 0x7b, 0x9c, 0x59, 0x7d, 0xe2, 0x50, 0x97, 0xd9, 0x86, 0x7a, 0x4d,
	0x60, 0x6d, 0xec, 0x86, 0xcc, 0xef, 0x46, 0xcc, 0xef, 0x1e, 0x4a, 0xe6, 0xcb, 0xcb, 0x5f, 0x7e,
	0xb3, 0x95, 0xfa, 0xfc, 0x5f, 0x5b, 0x0a, 0x5e, 0x8d, 0x7c, 0x5b, 0xc2, 0x15, 0x75, 0x61, 0x5d,
	0x98, 0xeb, 0xf6, 0x90, 0x38, 0x9a, 0xab, 0x99, 0x94, 0x53, 0xd7, 0x53, 0x17, 0xc5, 0x8e, 0xfb,
	0x49, 0xa7, 0xaf, 0x87, 0x3f, 0x5b, 0xd2, 0xb3, 0x35, 0x76, 0xc4, 0xc8, 0xb9, 0x24, 0x43, 0xef,
	0x40, 0xde, 0x77, 0xfa, 0xae, 0x66, 0x50, 0xe2, 0x68, 0x7c, 0xa0, 0x2e, 0x6d, 0x2f, 0xdc, 0xcb,
	0xe2, 0x9c, 0x94, 0xb5, 0x34, 0x3e, 0x40, 0xef, 0x83, 0x3a, 0xb0, 0x3d, 0x4e, 0xbc, 0xe0, 0xb2,
	0x88, 0xd5, 0xe3, 0xc4, 0xb1, 0x87, 0x4c, 0x1f, 0x05, 0xd7, 0xb5, 0xbc, 0xad, 0xdc, 0xcb, 0xe3,
	0xeb, 0x81, 0x5e, 0xdc, 0x65, 0xa3, 0xc7, 0x5b, 0x42, 0x59, 0x33, 0xd0, 0x07, 0xb0, 0x31, 0xe3,
	0xc7, 0xed, 0x33, 0x6a, 0x11, 0x4b, 0x33, 0xa9, 0x9a, 0x15, 0x8e, 0x6f, 0xc7, 0x1d, 0x3b, 0x81,
	0xb6, 0xa1, 0x99, 0xf4, 0x71, 0x26, 0x48, 0x95, 0x9d, 0xdf, 0xa7, 0x61, 0xb5, 0x62, 0x5b, 0x1e,
	0xb5, 0x3c, 0xdf, 0x0b, 0x33, 0xe5, 0x16, 0x64, 0x39, 0x33, 0xa9, 0xc7, 0x35, 0xd3, 0x91, 0xf9,
	0x38, 0x11, 0xa0, 0xdf, 0xc2, 0xad, 0x1e, 0x73, 0x3d, 0x4e, 0x74, 0xea, 0x72, 0x32, 0xd0, 0xbc,
	0x01, 0x91, 0xc9, 0x13, 0xde, 0x58, 0x98, 0x3b, 0xef, 0x5d, 0x41, 0x5c, 0x85, 0xba, 0x9c, 0xf5,
	0x98, 0xae, 0x71, 0x8a, 0x55, 0xb1, 0x5f, 0x20, 0x39, 0xd1, 0xbc, 0xc1, 0xa9, 0xd8, 0x2c, 0xbc,
	0xe9, 0x8f, 0xe0, 0x96, 0xdc, 0x7b, 0x02, 0xc6, 0x2f, 0x88, 0x67, 0x69, 0x8e, 0x37, 0xb0, 0xc3,
	0x14, 0xcb, 0x62, 0x35, 0xb4, 0x89, 0x36, 0xe8, 0x5c, 0xb4, 0xa5, 0x1e, 0xbd, 0x0b, 0xab, 0xac,
	0xab, 0x4b, 0x6e, 0x5c, 0xdb, 0xe6, 0x22, 0x9f, 0xf2, 0x38, 0xcf, 0xba, 0xba, 0x88, 0x15, 0xdb,
	0x36, 0x97, 0x44, 0xfc, 0x57, 0x81, 0x7c, 0x9d, 0x79, 0x5d, 0x3a, 0xd0, 0xce, 0x99, 0xed, 0xbb,
	0x68, 0x0b, 0xb2, 0xe1, 0xf9, 0xc7, 0x15, 0x53, 0x4e, 0xab, 0x0a, 0x5e, 0x0e, 0x85, 0x35, 0x03,
	0xe9, 0x50, 0x90, 0x81, 0x91, 0x01, 0xd5, 0x0c, 0xea, 0x92, 0x7d, 0x19, 0xfd, 0x9d, 0x2b, 0xa2,
	0x3f, 0x11, 0xe6, 0x65, 0xf4, 0xfc, 0x9b, 0xad, 0xd5, 0x29, 0xd1, 0x3e, 0x5e, 0x35, 0xa7, 0xd6,
	0x73, 0x40, 0x0e, 0x64, 0x65, 0xbd, 0x31, 0xc8, 0xc1, 0x0c, 0xc8, 0x81, 0x64, 0xe0, 0x6f, 0x8b,
	0xb0, 0x32, 0x65, 0x88, 0x2c, 0xd8, 0x8c, 0xc0, 0x3d, 0xae, 0x9d, 0x51, 0x62, 0x30, 0x8f, 0xbb,
	0xac, 0xeb, 0x07, 0x35, 0x25, 0x38, 0xc9, 0x1d, 0x3c, 0xba, 0xe2, 0x18, 0xed, 0xc0, 0xf1, 0x30,
	0xe6, 0x87, 0x55, 0x33, 0x41, 0x83, 0x7e, 0x07, 0xdf, 0x4b, 0xc6, 0x13, 0x39, 0x20, 0x73, 0xe6,
	0x0d, 0xb2, 0xec, 0x76, 0x12, 0x6a, 0xcc, 0x08, 0x51, 0xb8, 0xce, 0x5d, 0xcd, 0xf2, 0x34, 0x5d,
	0x20, 0x4e, 0x25, 0x5a, 0xee, 0xe0, 0x20, 0x09, 0xae, 0xa2, 0xb9, 0x86, 0x66, 0xd9, 0x9d, 0x89,
	0x6b, 0x94, 0x82, 0x78, 0x9d, 0x5f, 0x16, 0x22, 0x0e, 0xdb, 0xf3, 0x60, 0xa6, 0x22, 0xcc, 0xbc,
	0x76, 0x84, 0xc5, 0x39, 0x50, 0xf1, 0xe0, 0xfe, 0xa8, 0xc0, 0x23, 0x27, 0x78, 0x2f, 0x6c, 0xdf,
	0x23, 0xaf, 0xc6, 0xb3, 0xa7, 0x66, 0xb7, 0x17, 0x5e, 0xf3, 0x18, 0xdf, 0x8f, 0x30, 0xea, 0x57,
	0x13, 0xee, 0xa1, 0x07, 0x80, 0x62, 0xfd, 0x8b, 0x5f, 0x88, 0x22, 0x17, 0xfd, 0x3c, 0x8b, 0xd7,
	0xc6, 0x8d, 0xab, 0x73, 0x11, 0x54, 0x36, 0xfa, 0x21, 0x7c, 0x67, 0xda, 0xb8, 0x6b, 0x1b, 0x23,
	0xa2, 0x77, 0x6d, 0x57, 0xf4, 0xeb, 0x3c, 0x5e, 0x8f, 0x79, 0x94, 0x6d, 0x63, 0x54, 0xe9, 0xda,
	0x2e, 0x7a, 0x0c, 0x9b, 0xd3, 0x5e, 0xb6, 0xcf, 0x1d, 0x9f, 0x13, 0x66, 0x19, 0xf4, 0x42, 0x5d,
	0xda, 0x56, 0xee, 0xad, 0xe0, 0x1b, 0x31, 0xc7, 0xa6, 0x50, 0xd7, 0x02, 0x2d, 0x7a, 0x08, 0xeb,
	0xd3, 0xbe, 0x8e, 0x6b, 0xdb, 0x3d, 0xd9, 0x91, 0x0b, 0x31, 0xa7, 0x56, 0x20, 0x97, 0x85, 0xf4,
	0x8f, 0x34, 0xa8, 0x49, 0xc1, 0xa3, 0xeb, 0x70, 0x2d, 0x6c, 0x94, 0x61, 0x67, 0x0d, 0x17, 0xe8,
	0x29, 0x20, 0x8f, 0xf5, 0x2d, 0xea, 0x7a, 0xe4, 0x13, 0xc6, 0x07, 0xe1, 0xb5, 0xa8, 0x69, 0x41,
	0xfe, 0xdd, 0x24, 0xf2, 0xdb, 0xc2, 0xe3, 0x17, 0x8c, 0x0f, 0x04, 0x0c, 0x2e, 0xc8, 0x2d, 0xc6,
	0x12, 0x84, 0x20, 0x23, 0xf8, 0x0c, 0x1b, 0xa5, 0xf8, 0x8d, 0xee, 0x43, 0x21, 0x76, 0xc3, 0x21,
	0xdf, 0x99, 0x90, 0xef, 0x98, 0x5c, 0xf0, 0xfd, 0x5d, 0x00, 0xdd, 0xa5, 0x1a, 0xa7, 0x06, 0xd1,
	0xb8, 0xb8, 0x94, 0x0c, 0xce, 0x4a, 0x49, 0x89, 0xa3, 0x8f, 0x01, 0x5d, 0x7e, 0x3a, 0xdf, 0xfc,
	0xe5, 0x7c, 0xeb, 0xd2, 0xcb, 0x29, 0xf9, 0xfc, 0xa7, 0x02, 0x9b, 0xc9, 0x25, 0x86, 0xb6, 0x20,
	0x67, 0x52, 0xf7, 0x6c, 0x28, 0x5b, 0x7c, 0x38, 0xdc, 0x40, 0x28, 0x0a, 0x1a, 0xfc, 0x84, 0xf2,
	0x74, 0x9c, 0xf2, 0x77, 0x20, 0xdf, 0x1d, 0xda, 0xfa, 0x59, 0x34, 0x79, 0x2d, 0x08, 0x65, 0x4e,
	0xc8, 0xe4, 0xd8, 0x15, 0xd1, 0x97, 0xb9, 0x82, 0xbe, 0x6b, 0xaf, 0x42, 0xdf, 0xa2, 0x30, 0x9a,
	0xd0, 0x27, 0x83, 0xfb, 0x53, 0x06, 0xd0, 0xe5, 0x2a, 0x1a, 0x43, 0x2b, 0x31, 0xe8, 0xdb, 0xb0,
	0x32, 0xae, 0x5f, 0xa1, 0x4c, 0x0b, 0x65, 0x3e, 0x12, 0x0a, 0xd0, 0x71, 0xb0, 0x0b, 0xf1, 0x60,
	0x9f, 0xc9, 0xfc, 0x32, 0x08, 0xb5, 0x38, 0xe3, 0x23, 0xc2, 0x47, 0x4e, 0xd4, 0x63, 0xee, 0xbd,
	0x34, 0xbf, 0x8c, 0xaa, 0x70, 0xe8, 0x8c, 0x9c, 0x28, 0xc1, 0x62, 0x12, 0x74, 0x0c, 0xcb, 0x26,
	0xe5, 0x9a, 0xa1, 0x71, 0x4d, 0x0e, 0x61, 0x0f, 0x12, 0x9b, 0xe4, 0x24, 0xba, 0xba, 0x74, 0xc1,
	0x63, 0x67, 0x84, 0xa1, 0x30, 0xce, 0x25, 0x93, 0x7a, 0x9e, 0xd6, 0xa7, 0x32, 0x93, 0x12, 0xd3,
	0x3f, 0x4a, 0xa1, 0x7a, 0x68, 0x8e, 0xd7, 0x9c, 0x69, 0x01, 0xba, 0x03, 0xab, 0x32, 0xe8, 0x68,
	0xc7, 0x25, 0x41, 0xd8, 0x4a, 0x28, 0x8d, 0xcc, 0x7e, 0x0a, 0x9b, 0x5a, 0xbf, 0xef, 0xd2, 0x7e,
	0x70, 0x9f, 0xe7, 0xd4, 0x0d, 0x0f, 0x19, 0x74, 0xc2, 0x33, 0x3a, 0x12, 0xa5, 0x9e, 0xc5, 0xea,
	0xd8, 0xe2, 0x59, 0xcc, 0xe0, 0x09, 0x1d, 0x05, 0xa3, 0xb9, 0xe9, 0x0f, 0x39, 0x23, 0xc1, 0xa6,
	0x1a, 0xf7, 0xdd, 0x70, 0xec, 0xca, 0xe2, 0x55, 0x21, 0x6e, 0x47, 0x52, 0xf4, 0x00, 0xde, 0xea,
	0x53, 0x8b, 0x7a, 0xcc, 0x8b, 0x99, 0x82, 0x30, 0x2d, 0x48, 0xc5, 0xd8, 0x58, 0xe6, 0xc6, 0xdf,
	0xd3, 0xb0, 0x3e, 0x87, 0x36, 0xa4, 0xc2, 0x92, 0x45, 0xf9, 0x27, 0xb6, 0x7b, 0x16, 0x8d, 0xf2,
	0x72, 0x19, 0x64, 0xe7, 0x98, 0xc6, 0x73, 0xea, 0x06, 0x5f, 0x06, 0x32, 0x4b, 0xc6, 0xec, 0x3c,
	0x0b, 0xc5, 0x49, 0x83, 0xef, 0xc2, 0xff, 0x79, 0xf0, 0x65, 0x16, 0xe3, 0x2c, 0xaa, 0x81, 0xb0,
	0x90, 0x72, 0x63, 0x59, 0x89, 0xa3, 0x9b, 0x90, 0xf5, 0xa8, 0x36, 0x9c, 0xb4, 0x98, 0x2c, 0x5e,
	0x0e, 0x05, 0x25, 0x8e, 0x4a, 0xb0, 0x24, 0x7b, 0x9a, 0xba, 0xf8, 0x7a, 0xbd, 0x30, 0xf2, 0x93,
	0x4c, 0x9e, 0xc0, 0xda, 0x8c, 0x45, 0xf0, 0x41, 0xe4, 0x68, 0x2e, 0x1f, 0xc5, 0x3e, 0x88, 0xc4,
	0xba, 0x66, 0x04, 0x35, 0x14, 0x35, 0x60, 0x51, 0x43, 0x62, 0x21, 0x77, 0xd2, 0x60, 0x6d, 0x26,
	0xf1, 0xd0, 0x09, 0xac, 0xc8, 0x04, 0x0b, 0x88, 0xe4, 0x9e, 0xaa, 0x88, 0xb3, 0xde, 0x4e, 0xe4,
	0x30, 0x34, 0x6e, 0x69, 0x2e, 0xc7, 0x79, 0x73, 0xb2, 0x88, 0x0e, 0xfb, 0x57, 0x05, 0x72, 0x31,
	0x1b, 0xc4, 0x60, 0x63, 0xb6, 0x36, 0x04, 0x90, 0xc8, 0xcf, 0xe0, 0xe8, 0xab, 0x07, 0xbb, 0xaf,
	0x58, 0x24, 0xc1, 0x7e, 0x4f, 0xe8, 0x08, 0xdf, 0x70, 0xe6, 0xca, 0xd1, 0x87, 0x70, 0x73, 0x3e,
	0xd4, 0xb9, 0x36, 0xf4, 0xa9, 0x4c, 0x25, 0x75, 0x8e, 0xf3, 0xb3, 0x40, 0x2f, 0xcf, 0xff, 0x29,
	0x6c, 0x24, 0xa6, 0x09, 0xca, 0x83, 0x72, 0x26, 0xdf, 0x3e, 0xe5, 0x2c, 0x58, 0x99, 0x92, 0x65,
	0xc5, 0x44, 0x3f, 0x81, 0x6b, 0xce, 0x80, 0x91, 0x9e, 0x4c, 0xc2, 0xed, 0xa4, 0xa0, 0x8e, 0xdc,
	0xf0, 0x09, 0x28, 0x67, 0x82, 0xcf, 0x3a, 0x9c, 0x71, 0x06, 0xec, 0x48, 0x62, 0x7f, 0x00, 0x6a,
	0x04, 0x7a, 0x3c, 0x53, 0x54, 0xc1, 0x87, 0xcd, 0xa4, 0xf2, 0x14, 0xf1, 0x84, 0x4f, 0x04, 0x3b,
	0x5f, 0x2f, 0x40, 0x61, 0xb6, 0xe3, 0x21, 0xe7, 0xdb, 0x98, 0x80, 0x4f, 0x52, 0x2f, 0x99, 0x81,
	0x1d, 0xd8, 0xd4, 0xc3, 0xb7, 0x6e, 0x1e, 0x62, 0xfa, 0xe5, 0x88, 0xf2, 0x95, 0x9c, 0x8b, 0xa8,
	0x27, 0xe8, 0x10, 0x87, 0x5b, 0x11, 0x22, 0x33, 0x4d, 0x9f, 0x6b, 0xdd, 0x21, 0x25, 0x3d, 0x36,
	0xa4, 0x1e, 0xe9, 0xf9, 0xc3, 0xe1, 0x55, 0x1d, 0x41, 0x62, 0xd6, 0x22, 0xd7, 0xa3, 0xc0, 0xf3,
	0xc8, 0x1f, 0x0e, 0x4f, 0x52, 0x78, 0x43, 0x4f, 0x52, 0xa2, 0x8f, 0xe1, 0x7a, 0x84, 0x1a, 0x9b,
	0x5b, 0x3d, 0xf9, 0x26, 0x3d, 0x78, 0xf5, 0x51, 0xdb, 0x3b, 0x49, 0xe1, 0x75, 0xfd, 0xb2, 0xb8,
	0xbc, 0x0c, 0x8b, 0xe1, 0x63, 0xb7, 0xf3, 0x08, 0xd4, 0x24, 0x66, 0xe6, 0xcf, 0x63, 0x3b, 0xbf,
	0x81, 0x8d, 0xc4, 0xb8, 0xd0, 0xcf, 0x60, 0xb1, 0x4b, 0x35, 0x7d, 0x9c, 0x00, 0x77, 0xaf, 0x38,
	0xec, 0x61, 0xb7, 0x2c, 0xcc, 0xb1, 0x74, 0xdb, 0x69, 0xc0, 0xfa, 0x9c, 0x38, 0x12, 0x46, 0xc3,
	0xd9, 0x39, 0x25, 0x7d, 0x69, 0x4e, 0xd9, 0xf1, 0x61, 0x6d, 0x06, 0xea, 0x25, 0x4f, 0xc4, 0xfc,
	0x69, 0xe8, 0x00, 0xde, 0x9e, 0xbe, 0xfc, 0xe9, 0xb1, 0x68, 0x9d, 0xc5, 0x69, 0x90, 0xb0, 0x3f,
	0x87, 0xe5, 0xa8, 0x12, 0x83, 0xda, 0xb2, 0x7c, 0x93, 0xba, 0x1a, 0xb7, 0xa3, 0x3f, 0xb1, 0x26,
	0x02, 0xb4, 0x0d, 0x39, 0x83, 0x5a, 0xb6, 0xc9, 0x2c, 0xa1, 0x97, 0x21, 0xc4, 0x44, 0xef, 0xfd,
	0x27, 0x0d, 0x37, 0xe6, 0xf7, 0x2a, 0x74, 0x1f, 0xee, 0xb4, 0x70, 0xb3, 0xd3, 0xac, 0x34, 0x4f,
	0x49, 0xbd, 0xda, 0x6e, 0x97, 0x8e, 0xab, 0xa4, 0x55, 0xc2, 0x1d, 0xf2, 0xa4, 0xfa, 0x2b, 0xf2,
	0xb4, 0xd1, 0x6e, 0x55, 0x2b, 0xb5, 0xa3, 0x5a, 0xf5, 0xb0, 0x90, 0x42, 0x0f, 0xe1, 0x7e, 0xb2,
	0x69, 0xbb, 0x51, 0x6a, 0xb5, 0x4f, 0x9a, 0x1d, 0x72, 0x58, 0x3b, 0xae, 0xb6, 0x3b, 0x05, 0x05,
	0x7d, 0x04, 0x8f, 0x93, 0xcd, 0x2b, 0x25, 0x7c, 0x58, 0x6a, 0x34, 0x49, 0x07, 0x97, 0x1a, 0xed,
	0x52, 0xa5, 0x53, 0x6b, 0x36, 0xda, 0xa4, 0x5e, 0xc5, 0x4f, 0x4e, 0xab, 0x04, 0x37, 0x9b, 0x9d,
	0x42, 0x1a, 0x7d, 0x08, 0x3f, 0x4e, 0xf6, 0x6f, 0x54, 0x7f, 0xd9, 0x21, 0xa5, 0xe3, 0x63, 0x5c,
	0x3d, 0x2e, 0x75, 0xaa, 0xe4, 0x59, 0x15, 0xd7, 0x8e, 0x6a, 0x95, 0x52, 0xb0, 0x4f, 0xa0, 0x2f,
	0x2c, 0xa0, 0xc7, 0xf0, 0x7e, 0xb2, 0xfb, 0x69, 0xa9, 0x53, 0x6d, 0x77, 0x48, 0xad, 0x5e, 0x7f,
	0xda, 0x29, 0x95, 0x4f, 0xab, 0xe4, 0xa8, 0x76, 0x5a, 0x25, 0x8d, 0xa7, 0xf5, 0x72, 0x15, 0x17,
	0x32, 0x68, 0x1f, 0x1e, 0x5e, 0xe9, 0x5b, 0x3e, 0x6d, 0x56, 0x9e, 0x44, 0x2e, 0xd7, 0x36, 0x33,
	0x9f, 0xfd, 0xb9, 0x98, 0x2a, 0xff, 0xe8, 0xcb, 0xe7, 0x45, 0xe5, 0xab, 0xe7, 0x45, 0xe5, 0xdf,
	0xcf, 0x8b, 0xca, 0x1f, 0x5e, 0x14, 0x53, 0x5f, 0xbd, 0x28, 0xa6, 0xbe, 0x7e, 0x51, 0x4c, 0xfd,
	0xfa, 0xa6, 0xc7, 0x0c, 0x2a, 0xfe, 0x13, 0xdc, 0xbb, 0x98, 0xfd, 0x4f, 0xb4, 0xbb, 0x28, 0x7a,
	0xfe, 0x0f, 0xfe, 0x17, 0x00, 0x00, 0xff, 0xff, 0xc8, 0x7e, 0x6b, 0xcc, 0x31, 0x15, 0x00, 0x00,
}

func (m *Height) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Height) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Height) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RevisionHeight != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.RevisionHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.RevisionNumber != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.RevisionNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HostStateNftTokenName) > 0 {
		i -= len(m.HostStateNftTokenName)
		copy(dAtA[i:], m.HostStateNftTokenName)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.HostStateNftTokenName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.HostStateNftPolicyId) > 0 {
		i -= len(m.HostStateNftPolicyId)
		copy(dAtA[i:], m.HostStateNftPolicyId)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.HostStateNftPolicyId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.UpgradePath) > 0 {
		for iNdEx := len(m.UpgradePath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UpgradePath[iNdEx])
			copy(dAtA[i:], m.UpgradePath[iNdEx])
			i = encodeVarintMithril(dAtA, i, uint64(len(m.UpgradePath[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ProtocolParameters != nil {
		{
			size, err := m.ProtocolParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	n2, err2 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.TrustingPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.TrustingPeriod):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintMithril(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x2a
	if m.CurrentEpoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.CurrentEpoch))
		i--
		dAtA[i] = 0x20
	}
	if m.FrozenHeight != nil {
		{
			size, err := m.FrozenHeight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.LatestHeight != nil {
		{
			size, err := m.LatestHeight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IbcStateRoot) > 0 {
		i -= len(m.IbcStateRoot)
		copy(dAtA[i:], m.IbcStateRoot)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.IbcStateRoot)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LatestCertHashTxSnapshot) > 0 {
		i -= len(m.LatestCertHashTxSnapshot)
		copy(dAtA[i:], m.LatestCertHashTxSnapshot)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.LatestCertHashTxSnapshot)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FirstCertHashLatestEpoch != nil {
		{
			size, err := m.FirstCertHashLatestEpoch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Misbehaviour) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Misbehaviour) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Misbehaviour) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MithrilHeader2 != nil {
		{
			size, err := m.MithrilHeader2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MithrilHeader1 != nil {
		{
			size, err := m.MithrilHeader1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MithrilHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PreviousMithrilStakeDistributionCertificates) > 0 {
		for iNdEx := len(m.PreviousMithrilStakeDistributionCertificates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PreviousMithrilStakeDistributionCertificates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMithril(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.HostStateTxProof) > 0 {
		i -= len(m.HostStateTxProof)
		copy(dAtA[i:], m.HostStateTxProof)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.HostStateTxProof)))
		i--
		dAtA[i] = 0x42
	}
	if m.HostStateTxOutputIndex != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.HostStateTxOutputIndex))
		i--
		dAtA[i] = 0x38
	}
	if len(m.HostStateTxBodyCbor) > 0 {
		i -= len(m.HostStateTxBodyCbor)
		copy(dAtA[i:], m.HostStateTxBodyCbor)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.HostStateTxBodyCbor)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.HostStateTxHash) > 0 {
		i -= len(m.HostStateTxHash)
		copy(dAtA[i:], m.HostStateTxHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.HostStateTxHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TransactionSnapshotCertificate != nil {
		{
			size, err := m.TransactionSnapshotCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TransactionSnapshot != nil {
		{
			size, err := m.TransactionSnapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MithrilStakeDistributionCertificate != nil {
		{
			size, err := m.MithrilStakeDistributionCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MithrilStakeDistribution != nil {
		{
			size, err := m.MithrilStakeDistribution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MithrilStakeDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilStakeDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilStakeDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProtocolParameter != nil {
		{
			size, err := m.ProtocolParameter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CreatedAt != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.CertificateHash) > 0 {
		i -= len(m.CertificateHash)
		copy(dAtA[i:], m.CertificateHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.CertificateHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SignersWithStake) > 0 {
		for iNdEx := len(m.SignersWithStake) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignersWithStake[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMithril(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CardanoTransactionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardanoTransactionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardanoTransactionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CertificateHash) > 0 {
		i -= len(m.CertificateHash)
		copy(dAtA[i:], m.CertificateHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.CertificateHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x22
	}
	if m.BlockNumber != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MerkleRoot) > 0 {
		i -= len(m.MerkleRoot)
		copy(dAtA[i:], m.MerkleRoot)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.MerkleRoot)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MithrilCertificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilCertificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilCertificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GenesisSignature) > 0 {
		i -= len(m.GenesisSignature)
		copy(dAtA[i:], m.GenesisSignature)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.GenesisSignature)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MultiSignature) > 0 {
		i -= len(m.MultiSignature)
		copy(dAtA[i:], m.MultiSignature)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.MultiSignature)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AggregateVerificationKey) > 0 {
		i -= len(m.AggregateVerificationKey)
		copy(dAtA[i:], m.AggregateVerificationKey)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.AggregateVerificationKey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SignedMessage) > 0 {
		i -= len(m.SignedMessage)
		copy(dAtA[i:], m.SignedMessage)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.SignedMessage)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ProtocolMessage != nil {
		{
			size, err := m.ProtocolMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SignedEntityType != nil {
		{
			size, err := m.SignedEntityType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PreviousHash) > 0 {
		i -= len(m.PreviousHash)
		copy(dAtA[i:], m.PreviousHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.PreviousHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertificateMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMithril(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SealedAt) > 0 {
		i -= len(m.SealedAt)
		copy(dAtA[i:], m.SealedAt)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.SealedAt)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.InitiatedAt) > 0 {
		i -= len(m.InitiatedAt)
		copy(dAtA[i:], m.InitiatedAt)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.InitiatedAt)))
		i--
		dAtA[i] = 0x22
	}
	if m.ProtocolParameters != nil {
		{
			size, err := m.ProtocolParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProtocolVersion) > 0 {
		i -= len(m.ProtocolVersion)
		copy(dAtA[i:], m.ProtocolVersion)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ProtocolVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Network) > 0 {
		i -= len(m.Network)
		copy(dAtA[i:], m.Network)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Network)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignerWithStake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignerWithStake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignerWithStake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stake != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Stake))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PartyId) > 0 {
		i -= len(m.PartyId)
		copy(dAtA[i:], m.PartyId)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.PartyId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MessageParts) > 0 {
		for iNdEx := len(m.MessageParts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MessageParts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMithril(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MessagePart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessagePart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProtocolMessagePartValue) > 0 {
		i -= len(m.ProtocolMessagePartValue)
		copy(dAtA[i:], m.ProtocolMessagePartValue)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ProtocolMessagePartValue)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProtocolMessagePartKey != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.ProtocolMessagePartKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MithrilProtocolParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilProtocolParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilProtocolParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PhiF.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMithril(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.M != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.M))
		i--
		dAtA[i] = 0x10
	}
	if m.K != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.K))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolGenesisSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolGenesisSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolGenesisSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignedEntityType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedEntityType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedEntityType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entity != nil {
		{
			size := m.Entity.Size()
			i -= size
			if _, err := m.Entity.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SignedEntityType_MithrilStakeDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedEntityType_MithrilStakeDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MithrilStakeDistribution != nil {
		{
			size, err := m.MithrilStakeDistribution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SignedEntityType_CardanoStakeDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedEntityType_CardanoStakeDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CardanoStakeDistribution != nil {
		{
			size, err := m.CardanoStakeDistribution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SignedEntityType_CardanoImmutableFilesFull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedEntityType_CardanoImmutableFilesFull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CardanoImmutableFilesFull != nil {
		{
			size, err := m.CardanoImmutableFilesFull.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SignedEntityType_CardanoTransactions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedEntityType_CardanoTransactions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CardanoTransactions != nil {
		{
			size, err := m.CardanoTransactions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CardanoStakeDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardanoStakeDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardanoStakeDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CardanoImmutableFilesFull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardanoImmutableFilesFull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardanoImmutableFilesFull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Beacon != nil {
		{
			size, err := m.Beacon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CardanoTransactions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardanoTransactions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardanoTransactions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockNumber != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CardanoDbBeacon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardanoDbBeacon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardanoDbBeacon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ImmutableFileNumber != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.ImmutableFileNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Network) > 0 {
		i -= len(m.Network)
		copy(dAtA[i:], m.Network)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Network)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Fraction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fraction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Fraction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Denominator != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Denominator))
		i--
		dAtA[i] = 0x10
	}
	if m.Numerator != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Numerator))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMithril(dAtA []byte, offset int, v uint64) int {
	offset -= sovMithril(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Height) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RevisionNumber != 0 {
		n += 1 + sovMithril(uint64(m.RevisionNumber))
	}
	if m.RevisionHeight != 0 {
		n += 1 + sovMithril(uint64(m.RevisionHeight))
	}
	return n
}

func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.LatestHeight != nil {
		l = m.LatestHeight.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.FrozenHeight != nil {
		l = m.FrozenHeight.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.CurrentEpoch != 0 {
		n += 1 + sovMithril(uint64(m.CurrentEpoch))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.TrustingPeriod)
	n += 1 + l + sovMithril(uint64(l))
	if m.ProtocolParameters != nil {
		l = m.ProtocolParameters.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if len(m.UpgradePath) > 0 {
		for _, s := range m.UpgradePath {
			l = len(s)
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	l = len(m.HostStateNftPolicyId)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.HostStateNftTokenName)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovMithril(uint64(m.Timestamp))
	}
	if m.FirstCertHashLatestEpoch != nil {
		l = m.FirstCertHashLatestEpoch.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.LatestCertHashTxSnapshot)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.IbcStateRoot)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *Misbehaviour) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.MithrilHeader1 != nil {
		l = m.MithrilHeader1.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.MithrilHeader2 != nil {
		l = m.MithrilHeader2.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MithrilHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MithrilStakeDistribution != nil {
		l = m.MithrilStakeDistribution.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.MithrilStakeDistributionCertificate != nil {
		l = m.MithrilStakeDistributionCertificate.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.TransactionSnapshot != nil {
		l = m.TransactionSnapshot.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.TransactionSnapshotCertificate != nil {
		l = m.TransactionSnapshotCertificate.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.HostStateTxHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.HostStateTxBodyCbor)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.HostStateTxOutputIndex != 0 {
		n += 1 + sovMithril(uint64(m.HostStateTxOutputIndex))
	}
	l = len(m.HostStateTxProof)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if len(m.PreviousMithrilStakeDistributionCertificates) > 0 {
		for _, e := range m.PreviousMithrilStakeDistributionCertificates {
			l = e.Size()
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	return n
}

func (m *MithrilStakeDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if len(m.SignersWithStake) > 0 {
		for _, e := range m.SignersWithStake {
			l = e.Size()
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.CertificateHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovMithril(uint64(m.CreatedAt))
	}
	if m.ProtocolParameter != nil {
		l = m.ProtocolParameter.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *CardanoTransactionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerkleRoot)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovMithril(uint64(m.BlockNumber))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.CertificateHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MithrilCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.PreviousHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if m.SignedEntityType != nil {
		l = m.SignedEntityType.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.ProtocolMessage != nil {
		l = m.ProtocolMessage.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.SignedMessage)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.AggregateVerificationKey)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.MultiSignature)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.GenesisSignature)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *CertificateMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.ProtocolVersion)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.ProtocolParameters != nil {
		l = m.ProtocolParameters.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.InitiatedAt)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.SealedAt)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if len(m.Signers) > 0 {
		for _, e := range m.Signers {
			l = e.Size()
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	return n
}

func (m *SignerWithStake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartyId)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Stake != 0 {
		n += 1 + sovMithril(uint64(m.Stake))
	}
	return n
}

func (m *ProtocolMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MessageParts) > 0 {
		for _, e := range m.MessageParts {
			l = e.Size()
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	return n
}

func (m *MessagePart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolMessagePartKey != 0 {
		n += 1 + sovMithril(uint64(m.ProtocolMessagePartKey))
	}
	l = len(m.ProtocolMessagePartValue)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MithrilProtocolParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K != 0 {
		n += 1 + sovMithril(uint64(m.K))
	}
	if m.M != 0 {
		n += 1 + sovMithril(uint64(m.M))
	}
	l = m.PhiF.Size()
	n += 1 + l + sovMithril(uint64(l))
	return n
}

func (m *ProtocolGenesisSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *SignedEntityType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entity != nil {
		n += m.Entity.Size()
	}
	return n
}

func (m *SignedEntityType_MithrilStakeDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MithrilStakeDistribution != nil {
		l = m.MithrilStakeDistribution.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}
func (m *SignedEntityType_CardanoStakeDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardanoStakeDistribution != nil {
		l = m.CardanoStakeDistribution.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}
func (m *SignedEntityType_CardanoImmutableFilesFull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardanoImmutableFilesFull != nil {
		l = m.CardanoImmutableFilesFull.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}
func (m *SignedEntityType_CardanoTransactions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardanoTransactions != nil {
		l = m.CardanoTransactions.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}
func (m *CardanoStakeDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	return n
}

func (m *CardanoImmutableFilesFull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Beacon != nil {
		l = m.Beacon.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *CardanoTransactions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovMithril(uint64(m.BlockNumber))
	}
	return n
}

func (m *CardanoDbBeacon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if m.ImmutableFileNumber != 0 {
		n += 1 + sovMithril(uint64(m.ImmutableFileNumber))
	}
	return n
}

func (m *Fraction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Numerator != 0 {
		n += 1 + sovMithril(uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		n += 1 + sovMithril(uint64(m.Denominator))
	}
	return n
}

func sovMithril(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMithril(x uint64) (n int) {
	return sovMithril(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Height) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Height: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Height: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevisionNumber", wireType)
			}
			m.RevisionNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevisionNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevisionHeight", wireType)
			}
			m.RevisionHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevisionHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatestHeight == nil {
				m.LatestHeight = &Height{}
			}
			if err := m.LatestHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FrozenHeight == nil {
				m.FrozenHeight = &Height{}
			}
			if err := m.FrozenHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentEpoch", wireType)
			}
			m.CurrentEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustingPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.TrustingPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolParameters == nil {
				m.ProtocolParameters = &MithrilProtocolParameters{}
			}
			if err := m.ProtocolParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradePath = append(m.UpgradePath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostStateNftPolicyId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostStateNftPolicyId = append(m.HostStateNftPolicyId[:0], dAtA[iNdEx:postIndex]...)
			if m.HostStateNftPolicyId == nil {
				m.HostStateNftPolicyId = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostStateNftTokenName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostStateNftTokenName = append(m.HostStateNftTokenName[:0], dAtA[iNdEx:postIndex]...)
			if m.HostStateNftTokenName == nil {
				m.HostStateNftTokenName = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstCertHashLatestEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstCertHashLatestEpoch == nil {
				m.FirstCertHashLatestEpoch = &MithrilCertificate{}
			}
			if err := m.FirstCertHashLatestEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestCertHashTxSnapshot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestCertHashTxSnapshot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcStateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IbcStateRoot = append(m.IbcStateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.IbcStateRoot == nil {
				m.IbcStateRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Misbehaviour) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Misbehaviour: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Misbehaviour: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilHeader1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilHeader1 == nil {
				m.MithrilHeader1 = &MithrilHeader{}
			}
			if err := m.MithrilHeader1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilHeader2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilHeader2 == nil {
				m.MithrilHeader2 = &MithrilHeader{}
			}
			if err := m.MithrilHeader2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilStakeDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilStakeDistribution == nil {
				m.MithrilStakeDistribution = &MithrilStakeDistribution{}
			}
			if err := m.MithrilStakeDistribution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilStakeDistributionCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilStakeDistributionCertificate == nil {
				m.MithrilStakeDistributionCertificate = &MithrilCertificate{}
			}
			if err := m.MithrilStakeDistributionCertificate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionSnapshot == nil {
				m.TransactionSnapshot = &CardanoTransactionSnapshot{}
			}
			if err := m.TransactionSnapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionSnapshotCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionSnapshotCertificate == nil {
				m.TransactionSnapshotCertificate = &MithrilCertificate{}
			}
			if err := m.TransactionSnapshotCertificate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostStateTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostStateTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostStateTxBodyCbor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostStateTxBodyCbor = append(m.HostStateTxBodyCbor[:0], dAtA[iNdEx:postIndex]...)
			if m.HostStateTxBodyCbor == nil {
				m.HostStateTxBodyCbor = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostStateTxOutputIndex", wireType)
			}
			m.HostStateTxOutputIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostStateTxOutputIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostStateTxProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostStateTxProof = append(m.HostStateTxProof[:0], dAtA[iNdEx:postIndex]...)
			if m.HostStateTxProof == nil {
				m.HostStateTxProof = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousMithrilStakeDistributionCertificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousMithrilStakeDistributionCertificates = append(m.PreviousMithrilStakeDistributionCertificates, &MithrilCertificate{})
			if err := m.PreviousMithrilStakeDistributionCertificates[len(m.PreviousMithrilStakeDistributionCertificates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilStakeDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilStakeDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilStakeDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignersWithStake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignersWithStake = append(m.SignersWithStake, &SignerWithStake{})
			if err := m.SignersWithStake[len(m.SignersWithStake)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolParameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolParameter == nil {
				m.ProtocolParameter = &MithrilProtocolParameters{}
			}
			if err := m.ProtocolParameter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardanoTransactionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardanoTransactionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardanoTransactionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilCertificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilCertificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilCertificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedEntityType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedEntityType == nil {
				m.SignedEntityType = &SignedEntityType{}
			}
			if err := m.SignedEntityType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &CertificateMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolMessage == nil {
				m.ProtocolMessage = &ProtocolMessage{}
			}
			if err := m.ProtocolMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateVerificationKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregateVerificationKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolParameters == nil {
				m.ProtocolParameters = &MithrilProtocolParameters{}
			}
			if err := m.ProtocolParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SealedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, &SignerWithStake{})
			if err := m.Signers[len(m.Signers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignerWithStake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignerWithStake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignerWithStake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			m.Stake = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stake |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageParts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageParts = append(m.MessageParts, &MessagePart{})
			if err := m.MessageParts[len(m.MessageParts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessagePart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessagePart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessagePart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolMessagePartKey", wireType)
			}
			m.ProtocolMessagePartKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolMessagePartKey |= ProtocolMessagePartKey(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolMessagePartValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolMessagePartValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilProtocolParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilProtocolParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilProtocolParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			m.K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.K |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			m.M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.M |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhiF", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PhiF.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolGenesisSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolGenesisSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolGenesisSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedEntityType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedEntityType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedEntityType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilStakeDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MithrilStakeDistribution{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &SignedEntityType_MithrilStakeDistribution{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardanoStakeDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CardanoStakeDistribution{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &SignedEntityType_CardanoStakeDistribution{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardanoImmutableFilesFull", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CardanoImmutableFilesFull{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &SignedEntityType_CardanoImmutableFilesFull{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardanoTransactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CardanoTransactions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &SignedEntityType_CardanoTransactions{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardanoStakeDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardanoStakeDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardanoStakeDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardanoImmutableFilesFull) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardanoImmutableFilesFull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardanoImmutableFilesFull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beacon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Beacon == nil {
				m.Beacon = &CardanoDbBeacon{}
			}
			if err := m.Beacon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardanoTransactions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardanoTransactions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardanoTransactions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardanoDbBeacon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardanoDbBeacon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardanoDbBeacon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImmutableFileNumber", wireType)
			}
			m.ImmutableFileNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImmutableFileNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fraction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fraction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fraction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numerator", wireType)
			}
			m.Numerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numerator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denominator", wireType)
			}
			m.Denominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Denominator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMithril(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMithril
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMithril
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMithril
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMithril        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMithril          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMithril = fmt.Errorf("proto: unexpected end of group")
)
