// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/clients/mithril/v1/mithril.proto

package mithril

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ProtocolMessagePartKey int32

const (
	SNAPSHOT_DIGEST                  ProtocolMessagePartKey = 0
	CARDANO_TRANSACTIONS_MERKLE_ROOT ProtocolMessagePartKey = 1
	NEXT_AGGREGATE_VERIFICATION_KEY  ProtocolMessagePartKey = 2
	LATEST_IMMUTABLE_FILE_NUMBER     ProtocolMessagePartKey = 3
)

var ProtocolMessagePartKey_name = map[int32]string{
	0: "SNAPSHOT_DIGEST",
	1: "CARDANO_TRANSACTIONS_MERKLE_ROOT",
	2: "NEXT_AGGREGATE_VERIFICATION_KEY",
	3: "LATEST_IMMUTABLE_FILE_NUMBER",
}

var ProtocolMessagePartKey_value = map[string]int32{
	"SNAPSHOT_DIGEST":                  0,
	"CARDANO_TRANSACTIONS_MERKLE_ROOT": 1,
	"NEXT_AGGREGATE_VERIFICATION_KEY":  2,
	"LATEST_IMMUTABLE_FILE_NUMBER":     3,
}

func (x ProtocolMessagePartKey) String() string {
	return proto.EnumName(ProtocolMessagePartKey_name, int32(x))
}

func (ProtocolMessagePartKey) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{0}
}

type Height struct {
	// the immutable file number
	MithrilHeight uint64 `protobuf:"varint,1,opt,name=mithril_height,json=mithrilHeight,proto3" json:"mithril_height,omitempty"`
}

func (m *Height) Reset()      { *m = Height{} }
func (*Height) ProtoMessage() {}
func (*Height) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{0}
}
func (m *Height) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Height) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Height.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Height) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Height.Merge(m, src)
}
func (m *Height) XXX_Size() int {
	return m.Size()
}
func (m *Height) XXX_DiscardUnknown() {
	xxx_messageInfo_Height.DiscardUnknown(m)
}

var xxx_messageInfo_Height proto.InternalMessageInfo

type ClientState struct {
	// Chain id
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Latest height the client was updated to
	LatestHeight *Height `protobuf:"bytes,2,opt,name=latest_height,json=latestHeight,proto3" json:"latest_height,omitempty"`
	// Block height when the client was frozen due to a misbehaviour
	FrozenHeight *Height `protobuf:"bytes,3,opt,name=frozen_height,json=frozenHeight,proto3" json:"frozen_height,omitempty"`
	// Epoch number of current chain state
	CurrentEpoch       uint64                     `protobuf:"varint,4,opt,name=current_epoch,json=currentEpoch,proto3" json:"current_epoch,omitempty"`
	TrustingPeriod     time.Duration              `protobuf:"bytes,5,opt,name=trusting_period,json=trustingPeriod,proto3,stdduration" json:"trusting_period"`
	ProtocolParameters *MithrilProtocolParameters `protobuf:"bytes,6,opt,name=protocol_parameters,json=protocolParameters,proto3" json:"protocol_parameters,omitempty"`
	// Path at which next upgraded client will be committed.
	UpgradePath []string `protobuf:"bytes,7,rep,name=upgrade_path,json=upgradePath,proto3" json:"upgrade_path,omitempty"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{1}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

type ConsensusState struct {
	Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// First certificate hash of latest epoch of mithril stake distribution
	FcHashLatestEpochMsd string `protobuf:"bytes,2,opt,name=fc_hash_latest_epoch_msd,json=fcHashLatestEpochMsd,proto3" json:"fc_hash_latest_epoch_msd,omitempty"`
	// Latest certificate hash of mithril stake distribution
	LatestCertHashMsd string `protobuf:"bytes,3,opt,name=latest_cert_hash_msd,json=latestCertHashMsd,proto3" json:"latest_cert_hash_msd,omitempty"`
	// First certificate hash of latest epoch of transaction snapshot
	FcHashLatestEpochTs string `protobuf:"bytes,4,opt,name=fc_hash_latest_epoch_ts,json=fcHashLatestEpochTs,proto3" json:"fc_hash_latest_epoch_ts,omitempty"`
	// Latest certificate hash of transaction snapshot
	LatestCertHashTs string `protobuf:"bytes,5,opt,name=latest_cert_hash_ts,json=latestCertHashTs,proto3" json:"latest_cert_hash_ts,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{2}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

type Misbehaviour struct {
	// ClientID is deprecated
	ClientId       string         `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"` // Deprecated: Do not use.
	MithrilHeader1 *MithrilHeader `protobuf:"bytes,2,opt,name=mithril_header_1,json=mithrilHeader1,proto3" json:"mithril_header_1,omitempty"`
	MithrilHeader2 *MithrilHeader `protobuf:"bytes,3,opt,name=mithril_header_2,json=mithrilHeader2,proto3" json:"mithril_header_2,omitempty"`
}

func (m *Misbehaviour) Reset()         { *m = Misbehaviour{} }
func (m *Misbehaviour) String() string { return proto.CompactTextString(m) }
func (*Misbehaviour) ProtoMessage()    {}
func (*Misbehaviour) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{3}
}
func (m *Misbehaviour) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Misbehaviour) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Misbehaviour.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Misbehaviour) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Misbehaviour.Merge(m, src)
}
func (m *Misbehaviour) XXX_Size() int {
	return m.Size()
}
func (m *Misbehaviour) XXX_DiscardUnknown() {
	xxx_messageInfo_Misbehaviour.DiscardUnknown(m)
}

var xxx_messageInfo_Misbehaviour proto.InternalMessageInfo

type MithrilHeader struct {
	MithrilStakeDistribution            *MithrilStakeDistribution   `protobuf:"bytes,1,opt,name=mithril_stake_distribution,json=mithrilStakeDistribution,proto3" json:"mithril_stake_distribution,omitempty"`
	MithrilStakeDistributionCertificate *MithrilCertificate         `protobuf:"bytes,2,opt,name=mithril_stake_distribution_certificate,json=mithrilStakeDistributionCertificate,proto3" json:"mithril_stake_distribution_certificate,omitempty"`
	TransactionSnapshot                 *CardanoTransactionSnapshot `protobuf:"bytes,3,opt,name=transaction_snapshot,json=transactionSnapshot,proto3" json:"transaction_snapshot,omitempty"`
	TransactionSnapshotCertificate      *MithrilCertificate         `protobuf:"bytes,4,opt,name=transaction_snapshot_certificate,json=transactionSnapshotCertificate,proto3" json:"transaction_snapshot_certificate,omitempty"`
}

func (m *MithrilHeader) Reset()         { *m = MithrilHeader{} }
func (m *MithrilHeader) String() string { return proto.CompactTextString(m) }
func (*MithrilHeader) ProtoMessage()    {}
func (*MithrilHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{4}
}
func (m *MithrilHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilHeader.Merge(m, src)
}
func (m *MithrilHeader) XXX_Size() int {
	return m.Size()
}
func (m *MithrilHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilHeader.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilHeader proto.InternalMessageInfo

type MithrilStakeDistribution struct {
	Epoch             uint64                     `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	SignersWithStake  []*SignerWithStake         `protobuf:"bytes,2,rep,name=signers_with_stake,json=signersWithStake,proto3" json:"signers_with_stake,omitempty"`
	Hash              string                     `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	CertificateHash   string                     `protobuf:"bytes,4,opt,name=certificate_hash,json=certificateHash,proto3" json:"certificate_hash,omitempty"`
	CreatedAt         uint64                     `protobuf:"varint,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	ProtocolParameter *MithrilProtocolParameters `protobuf:"bytes,6,opt,name=protocol_parameter,json=protocolParameter,proto3" json:"protocol_parameter,omitempty"`
}

func (m *MithrilStakeDistribution) Reset()         { *m = MithrilStakeDistribution{} }
func (m *MithrilStakeDistribution) String() string { return proto.CompactTextString(m) }
func (*MithrilStakeDistribution) ProtoMessage()    {}
func (*MithrilStakeDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{5}
}
func (m *MithrilStakeDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilStakeDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilStakeDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilStakeDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilStakeDistribution.Merge(m, src)
}
func (m *MithrilStakeDistribution) XXX_Size() int {
	return m.Size()
}
func (m *MithrilStakeDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilStakeDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilStakeDistribution proto.InternalMessageInfo

type CardanoTransactionSnapshot struct {
	SnapshotHash    string  `protobuf:"bytes,1,opt,name=snapshot_hash,json=snapshotHash,proto3" json:"snapshot_hash,omitempty"`
	MerkleRoot      string  `protobuf:"bytes,2,opt,name=merkle_root,json=merkleRoot,proto3" json:"merkle_root,omitempty"`
	CertificateHash string  `protobuf:"bytes,3,opt,name=certificate_hash,json=certificateHash,proto3" json:"certificate_hash,omitempty"`
	Epoch           uint64  `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Height          *Height `protobuf:"bytes,5,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *CardanoTransactionSnapshot) Reset()         { *m = CardanoTransactionSnapshot{} }
func (m *CardanoTransactionSnapshot) String() string { return proto.CompactTextString(m) }
func (*CardanoTransactionSnapshot) ProtoMessage()    {}
func (*CardanoTransactionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{6}
}
func (m *CardanoTransactionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardanoTransactionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardanoTransactionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardanoTransactionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardanoTransactionSnapshot.Merge(m, src)
}
func (m *CardanoTransactionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CardanoTransactionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CardanoTransactionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CardanoTransactionSnapshot proto.InternalMessageInfo

type MithrilCertificate struct {
	Hash                     string                `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	PreviousHash             string                `protobuf:"bytes,2,opt,name=previous_hash,json=previousHash,proto3" json:"previous_hash,omitempty"`
	Epoch                    uint64                `protobuf:"varint,3,opt,name=epoch,proto3" json:"epoch,omitempty"`
	SignedEntityType         *SignedEntityType     `protobuf:"bytes,4,opt,name=signed_entity_type,json=signedEntityType,proto3" json:"signed_entity_type,omitempty"`
	Metadata                 *CertificateMetadata  `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
	ProtocolMessage          *ProtocolMessage      `protobuf:"bytes,6,opt,name=protocol_message,json=protocolMessage,proto3" json:"protocol_message,omitempty"`
	SignedMessage            string                `protobuf:"bytes,7,opt,name=signed_message,json=signedMessage,proto3" json:"signed_message,omitempty"`
	AggregateVerificationKey string                `protobuf:"bytes,8,opt,name=aggregate_verification_key,json=aggregateVerificationKey,proto3" json:"aggregate_verification_key,omitempty"`
	Signature                *CertificateSignature `protobuf:"bytes,9,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MithrilCertificate) Reset()         { *m = MithrilCertificate{} }
func (m *MithrilCertificate) String() string { return proto.CompactTextString(m) }
func (*MithrilCertificate) ProtoMessage()    {}
func (*MithrilCertificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{7}
}
func (m *MithrilCertificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilCertificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilCertificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilCertificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilCertificate.Merge(m, src)
}
func (m *MithrilCertificate) XXX_Size() int {
	return m.Size()
}
func (m *MithrilCertificate) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilCertificate.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilCertificate proto.InternalMessageInfo

type CertificateMetadata struct {
	ProtocolVersion    string                     `protobuf:"bytes,1,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	ProtocolParameters *MithrilProtocolParameters `protobuf:"bytes,2,opt,name=protocol_parameters,json=protocolParameters,proto3" json:"protocol_parameters,omitempty"`
	InitiatedAt        uint64                     `protobuf:"varint,3,opt,name=initiatedAt,proto3" json:"initiatedAt,omitempty"`
	SealedAt           uint64                     `protobuf:"varint,4,opt,name=sealedAt,proto3" json:"sealedAt,omitempty"`
	Signers            []*SignerWithStake         `protobuf:"bytes,5,rep,name=signers,proto3" json:"signers,omitempty"`
}

func (m *CertificateMetadata) Reset()         { *m = CertificateMetadata{} }
func (m *CertificateMetadata) String() string { return proto.CompactTextString(m) }
func (*CertificateMetadata) ProtoMessage()    {}
func (*CertificateMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{8}
}
func (m *CertificateMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertificateMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertificateMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateMetadata.Merge(m, src)
}
func (m *CertificateMetadata) XXX_Size() int {
	return m.Size()
}
func (m *CertificateMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateMetadata proto.InternalMessageInfo

type SignerWithStake struct {
	PartyId string `protobuf:"bytes,1,opt,name=party_id,json=partyId,proto3" json:"party_id,omitempty"`
	Stake   uint64 `protobuf:"varint,2,opt,name=stake,proto3" json:"stake,omitempty"`
}

func (m *SignerWithStake) Reset()         { *m = SignerWithStake{} }
func (m *SignerWithStake) String() string { return proto.CompactTextString(m) }
func (*SignerWithStake) ProtoMessage()    {}
func (*SignerWithStake) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{9}
}
func (m *SignerWithStake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignerWithStake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignerWithStake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignerWithStake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignerWithStake.Merge(m, src)
}
func (m *SignerWithStake) XXX_Size() int {
	return m.Size()
}
func (m *SignerWithStake) XXX_DiscardUnknown() {
	xxx_messageInfo_SignerWithStake.DiscardUnknown(m)
}

var xxx_messageInfo_SignerWithStake proto.InternalMessageInfo

type ProtocolMessage struct {
	MessageParts []*MessagePart `protobuf:"bytes,1,rep,name=message_parts,json=messageParts,proto3" json:"message_parts,omitempty"`
}

func (m *ProtocolMessage) Reset()         { *m = ProtocolMessage{} }
func (m *ProtocolMessage) String() string { return proto.CompactTextString(m) }
func (*ProtocolMessage) ProtoMessage()    {}
func (*ProtocolMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{10}
}
func (m *ProtocolMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolMessage.Merge(m, src)
}
func (m *ProtocolMessage) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolMessage proto.InternalMessageInfo

type MessagePart struct {
	ProtocolMessagePartKey   ProtocolMessagePartKey `protobuf:"varint,1,opt,name=protocol_message_part_key,json=protocolMessagePartKey,proto3,enum=ibc.clients.mithril.v1.ProtocolMessagePartKey" json:"protocol_message_part_key,omitempty"`
	ProtocolMessagePartValue string                 `protobuf:"bytes,2,opt,name=protocol_message_part_value,json=protocolMessagePartValue,proto3" json:"protocol_message_part_value,omitempty"`
}

func (m *MessagePart) Reset()         { *m = MessagePart{} }
func (m *MessagePart) String() string { return proto.CompactTextString(m) }
func (*MessagePart) ProtoMessage()    {}
func (*MessagePart) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{11}
}
func (m *MessagePart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessagePart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessagePart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessagePart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessagePart.Merge(m, src)
}
func (m *MessagePart) XXX_Size() int {
	return m.Size()
}
func (m *MessagePart) XXX_DiscardUnknown() {
	xxx_messageInfo_MessagePart.DiscardUnknown(m)
}

var xxx_messageInfo_MessagePart proto.InternalMessageInfo

type MithrilProtocolParameters struct {
	// Quorum parameter
	K uint64 `protobuf:"varint,1,opt,name=k,proto3" json:"k,omitempty"`
	// Security parameter (number of lotteries)
	M uint64 `protobuf:"varint,2,opt,name=m,proto3" json:"m,omitempty"`
	// f in phi(w) = 1 - (1 - f)^w, where w is the stake of a participant
	PhiF float64 `protobuf:"fixed64,3,opt,name=phi_f,json=phiF,proto3" json:"phi_f,omitempty"`
}

func (m *MithrilProtocolParameters) Reset()         { *m = MithrilProtocolParameters{} }
func (m *MithrilProtocolParameters) String() string { return proto.CompactTextString(m) }
func (*MithrilProtocolParameters) ProtoMessage()    {}
func (*MithrilProtocolParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{12}
}
func (m *MithrilProtocolParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MithrilProtocolParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MithrilProtocolParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MithrilProtocolParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MithrilProtocolParameters.Merge(m, src)
}
func (m *MithrilProtocolParameters) XXX_Size() int {
	return m.Size()
}
func (m *MithrilProtocolParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_MithrilProtocolParameters.DiscardUnknown(m)
}

var xxx_messageInfo_MithrilProtocolParameters proto.InternalMessageInfo

type CertificateSignature struct {
	// Types that are valid to be assigned to SigType:
	//	*CertificateSignature_GenesisSignature
	//	*CertificateSignature_MultiSignature
	SigType isCertificateSignature_SigType `protobuf_oneof:"sig_type"`
}

func (m *CertificateSignature) Reset()         { *m = CertificateSignature{} }
func (m *CertificateSignature) String() string { return proto.CompactTextString(m) }
func (*CertificateSignature) ProtoMessage()    {}
func (*CertificateSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{13}
}
func (m *CertificateSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertificateSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertificateSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateSignature.Merge(m, src)
}
func (m *CertificateSignature) XXX_Size() int {
	return m.Size()
}
func (m *CertificateSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateSignature.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateSignature proto.InternalMessageInfo

type isCertificateSignature_SigType interface {
	isCertificateSignature_SigType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CertificateSignature_GenesisSignature struct {
	GenesisSignature *GenesisSignature `protobuf:"bytes,1,opt,name=genesis_signature,json=genesisSignature,proto3,oneof" json:"genesis_signature,omitempty"`
}
type CertificateSignature_MultiSignature struct {
	MultiSignature *MultiSignature `protobuf:"bytes,2,opt,name=multi_signature,json=multiSignature,proto3,oneof" json:"multi_signature,omitempty"`
}

func (*CertificateSignature_GenesisSignature) isCertificateSignature_SigType() {}
func (*CertificateSignature_MultiSignature) isCertificateSignature_SigType()   {}

func (m *CertificateSignature) GetSigType() isCertificateSignature_SigType {
	if m != nil {
		return m.SigType
	}
	return nil
}

func (m *CertificateSignature) GetGenesisSignature() *GenesisSignature {
	if x, ok := m.GetSigType().(*CertificateSignature_GenesisSignature); ok {
		return x.GenesisSignature
	}
	return nil
}

func (m *CertificateSignature) GetMultiSignature() *MultiSignature {
	if x, ok := m.GetSigType().(*CertificateSignature_MultiSignature); ok {
		return x.MultiSignature
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CertificateSignature) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CertificateSignature_GenesisSignature)(nil),
		(*CertificateSignature_MultiSignature)(nil),
	}
}

type GenesisSignature struct {
	ProtocolGenesisSignature *ProtocolGenesisSignature `protobuf:"bytes,1,opt,name=protocol_genesis_signature,json=protocolGenesisSignature,proto3" json:"protocol_genesis_signature,omitempty"`
}

func (m *GenesisSignature) Reset()         { *m = GenesisSignature{} }
func (m *GenesisSignature) String() string { return proto.CompactTextString(m) }
func (*GenesisSignature) ProtoMessage()    {}
func (*GenesisSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{14}
}
func (m *GenesisSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisSignature.Merge(m, src)
}
func (m *GenesisSignature) XXX_Size() int {
	return m.Size()
}
func (m *GenesisSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisSignature.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisSignature proto.InternalMessageInfo

func (m *GenesisSignature) GetProtocolGenesisSignature() *ProtocolGenesisSignature {
	if m != nil {
		return m.ProtocolGenesisSignature
	}
	return nil
}

// ProtocolGenesisSignature wraps a cryptographic signature.
type ProtocolGenesisSignature struct {
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *ProtocolGenesisSignature) Reset()         { *m = ProtocolGenesisSignature{} }
func (m *ProtocolGenesisSignature) String() string { return proto.CompactTextString(m) }
func (*ProtocolGenesisSignature) ProtoMessage()    {}
func (*ProtocolGenesisSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{15}
}
func (m *ProtocolGenesisSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolGenesisSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolGenesisSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolGenesisSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolGenesisSignature.Merge(m, src)
}
func (m *ProtocolGenesisSignature) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolGenesisSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolGenesisSignature.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolGenesisSignature proto.InternalMessageInfo

func (m *ProtocolGenesisSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// MultiSignature represents a collective signature.
type MultiSignature struct {
	EntityType *SignedEntityType       `protobuf:"bytes,1,opt,name=entity_type,json=entityType,proto3" json:"entity_type,omitempty"`
	Signature  *ProtocolMultiSignature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MultiSignature) Reset()         { *m = MultiSignature{} }
func (m *MultiSignature) String() string { return proto.CompactTextString(m) }
func (*MultiSignature) ProtoMessage()    {}
func (*MultiSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{16}
}
func (m *MultiSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiSignature.Merge(m, src)
}
func (m *MultiSignature) XXX_Size() int {
	return m.Size()
}
func (m *MultiSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiSignature.DiscardUnknown(m)
}

var xxx_messageInfo_MultiSignature proto.InternalMessageInfo

func (m *MultiSignature) GetEntityType() *SignedEntityType {
	if m != nil {
		return m.EntityType
	}
	return nil
}

func (m *MultiSignature) GetSignature() *ProtocolMultiSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// An entity type associated with the signature.
type SignedEntityType struct {
	// Types that are valid to be assigned to Entity:
	//
	//	*SignedEntityType_MithrilStakeDistribution
	//	*SignedEntityType_CardanoStakeDistribution
	//	*SignedEntityType_CardanoImmutableFilesFull
	//	*SignedEntityType_CardanoTransactions
	Entity isSignedEntityType_Entity `protobuf_oneof:"entity"`
}

func (m *SignedEntityType) Reset()         { *m = SignedEntityType{} }
func (m *SignedEntityType) String() string { return proto.CompactTextString(m) }
func (*SignedEntityType) ProtoMessage()    {}
func (*SignedEntityType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{17}
}
func (m *SignedEntityType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedEntityType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedEntityType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedEntityType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedEntityType.Merge(m, src)
}
func (m *SignedEntityType) XXX_Size() int {
	return m.Size()
}
func (m *SignedEntityType) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedEntityType.DiscardUnknown(m)
}

var xxx_messageInfo_SignedEntityType proto.InternalMessageInfo

type isSignedEntityType_Entity interface {
	isSignedEntityType_Entity()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SignedEntityType_MithrilStakeDistribution struct {
	MithrilStakeDistribution *MithrilStakeDistribution `protobuf:"bytes,1,opt,name=mithril_stake_distribution,json=mithrilStakeDistribution,proto3,oneof" json:"mithril_stake_distribution,omitempty"`
}
type SignedEntityType_CardanoStakeDistribution struct {
	CardanoStakeDistribution *CardanoStakeDistribution `protobuf:"bytes,2,opt,name=cardano_stake_distribution,json=cardanoStakeDistribution,proto3,oneof" json:"cardano_stake_distribution,omitempty"`
}
type SignedEntityType_CardanoImmutableFilesFull struct {
	CardanoImmutableFilesFull *CardanoImmutableFilesFull `protobuf:"bytes,3,opt,name=cardano_immutable_files_full,json=cardanoImmutableFilesFull,proto3,oneof" json:"cardano_immutable_files_full,omitempty"`
}
type SignedEntityType_CardanoTransactions struct {
	CardanoTransactions *CardanoTransactions `protobuf:"bytes,4,opt,name=cardano_transactions,json=cardanoTransactions,proto3,oneof" json:"cardano_transactions,omitempty"`
}

func (*SignedEntityType_MithrilStakeDistribution) isSignedEntityType_Entity()  {}
func (*SignedEntityType_CardanoStakeDistribution) isSignedEntityType_Entity()  {}
func (*SignedEntityType_CardanoImmutableFilesFull) isSignedEntityType_Entity() {}
func (*SignedEntityType_CardanoTransactions) isSignedEntityType_Entity()       {}

func (m *SignedEntityType) GetEntity() isSignedEntityType_Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *SignedEntityType) GetMithrilStakeDistribution() *MithrilStakeDistribution {
	if x, ok := m.GetEntity().(*SignedEntityType_MithrilStakeDistribution); ok {
		return x.MithrilStakeDistribution
	}
	return nil
}

func (m *SignedEntityType) GetCardanoStakeDistribution() *CardanoStakeDistribution {
	if x, ok := m.GetEntity().(*SignedEntityType_CardanoStakeDistribution); ok {
		return x.CardanoStakeDistribution
	}
	return nil
}

func (m *SignedEntityType) GetCardanoImmutableFilesFull() *CardanoImmutableFilesFull {
	if x, ok := m.GetEntity().(*SignedEntityType_CardanoImmutableFilesFull); ok {
		return x.CardanoImmutableFilesFull
	}
	return nil
}

func (m *SignedEntityType) GetCardanoTransactions() *CardanoTransactions {
	if x, ok := m.GetEntity().(*SignedEntityType_CardanoTransactions); ok {
		return x.CardanoTransactions
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SignedEntityType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SignedEntityType_MithrilStakeDistribution)(nil),
		(*SignedEntityType_CardanoStakeDistribution)(nil),
		(*SignedEntityType_CardanoImmutableFilesFull)(nil),
		(*SignedEntityType_CardanoTransactions)(nil),
	}
}

type CardanoStakeDistribution struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *CardanoStakeDistribution) Reset()         { *m = CardanoStakeDistribution{} }
func (m *CardanoStakeDistribution) String() string { return proto.CompactTextString(m) }
func (*CardanoStakeDistribution) ProtoMessage()    {}
func (*CardanoStakeDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{18}
}
func (m *CardanoStakeDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardanoStakeDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardanoStakeDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardanoStakeDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardanoStakeDistribution.Merge(m, src)
}
func (m *CardanoStakeDistribution) XXX_Size() int {
	return m.Size()
}
func (m *CardanoStakeDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_CardanoStakeDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_CardanoStakeDistribution proto.InternalMessageInfo

func (m *CardanoStakeDistribution) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type CardanoImmutableFilesFull struct {
	Beacon *CardanoDbBeacon `protobuf:"bytes,1,opt,name=beacon,proto3" json:"beacon,omitempty"`
}

func (m *CardanoImmutableFilesFull) Reset()         { *m = CardanoImmutableFilesFull{} }
func (m *CardanoImmutableFilesFull) String() string { return proto.CompactTextString(m) }
func (*CardanoImmutableFilesFull) ProtoMessage()    {}
func (*CardanoImmutableFilesFull) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{19}
}
func (m *CardanoImmutableFilesFull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardanoImmutableFilesFull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardanoImmutableFilesFull.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardanoImmutableFilesFull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardanoImmutableFilesFull.Merge(m, src)
}
func (m *CardanoImmutableFilesFull) XXX_Size() int {
	return m.Size()
}
func (m *CardanoImmutableFilesFull) XXX_DiscardUnknown() {
	xxx_messageInfo_CardanoImmutableFilesFull.DiscardUnknown(m)
}

var xxx_messageInfo_CardanoImmutableFilesFull proto.InternalMessageInfo

func (m *CardanoImmutableFilesFull) GetBeacon() *CardanoDbBeacon {
	if m != nil {
		return m.Beacon
	}
	return nil
}

type CardanoTransactions struct {
	Beacon *CardanoDbBeacon `protobuf:"bytes,1,opt,name=beacon,proto3" json:"beacon,omitempty"`
}

func (m *CardanoTransactions) Reset()         { *m = CardanoTransactions{} }
func (m *CardanoTransactions) String() string { return proto.CompactTextString(m) }
func (*CardanoTransactions) ProtoMessage()    {}
func (*CardanoTransactions) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{20}
}
func (m *CardanoTransactions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardanoTransactions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardanoTransactions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardanoTransactions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardanoTransactions.Merge(m, src)
}
func (m *CardanoTransactions) XXX_Size() int {
	return m.Size()
}
func (m *CardanoTransactions) XXX_DiscardUnknown() {
	xxx_messageInfo_CardanoTransactions.DiscardUnknown(m)
}

var xxx_messageInfo_CardanoTransactions proto.InternalMessageInfo

func (m *CardanoTransactions) GetBeacon() *CardanoDbBeacon {
	if m != nil {
		return m.Beacon
	}
	return nil
}

type CardanoDbBeacon struct {
	Network             string `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Epoch               uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	ImmutableFileNumber uint64 `protobuf:"varint,3,opt,name=immutable_file_number,json=immutableFileNumber,proto3" json:"immutable_file_number,omitempty"`
}

func (m *CardanoDbBeacon) Reset()         { *m = CardanoDbBeacon{} }
func (m *CardanoDbBeacon) String() string { return proto.CompactTextString(m) }
func (*CardanoDbBeacon) ProtoMessage()    {}
func (*CardanoDbBeacon) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{21}
}
func (m *CardanoDbBeacon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardanoDbBeacon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardanoDbBeacon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardanoDbBeacon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardanoDbBeacon.Merge(m, src)
}
func (m *CardanoDbBeacon) XXX_Size() int {
	return m.Size()
}
func (m *CardanoDbBeacon) XXX_DiscardUnknown() {
	xxx_messageInfo_CardanoDbBeacon.DiscardUnknown(m)
}

var xxx_messageInfo_CardanoDbBeacon proto.InternalMessageInfo

func (m *CardanoDbBeacon) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *CardanoDbBeacon) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *CardanoDbBeacon) GetImmutableFileNumber() uint64 {
	if m != nil {
		return m.ImmutableFileNumber
	}
	return 0
}

// ProtocolMultiSignature wraps a multi-signature.
type ProtocolMultiSignature struct {
	Signatures []byte `protobuf:"bytes,1,opt,name=signatures,proto3" json:"signatures,omitempty"`
	BatchProof []byte `protobuf:"bytes,2,opt,name=batch_proof,json=batchProof,proto3" json:"batch_proof,omitempty"`
}

func (m *ProtocolMultiSignature) Reset()         { *m = ProtocolMultiSignature{} }
func (m *ProtocolMultiSignature) String() string { return proto.CompactTextString(m) }
func (*ProtocolMultiSignature) ProtoMessage()    {}
func (*ProtocolMultiSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_4410ce5523531b7b, []int{22}
}
func (m *ProtocolMultiSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolMultiSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolMultiSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolMultiSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolMultiSignature.Merge(m, src)
}
func (m *ProtocolMultiSignature) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolMultiSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolMultiSignature.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolMultiSignature proto.InternalMessageInfo

func (m *ProtocolMultiSignature) GetSignatures() []byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *ProtocolMultiSignature) GetBatchProof() []byte {
	if m != nil {
		return m.BatchProof
	}
	return nil
}

func init() {
	proto.RegisterEnum("ibc.clients.mithril.v1.ProtocolMessagePartKey", ProtocolMessagePartKey_name, ProtocolMessagePartKey_value)
	proto.RegisterType((*Height)(nil), "ibc.clients.mithril.v1.Height")
	proto.RegisterType((*ClientState)(nil), "ibc.clients.mithril.v1.ClientState")
	proto.RegisterType((*ConsensusState)(nil), "ibc.clients.mithril.v1.ConsensusState")
	proto.RegisterType((*Misbehaviour)(nil), "ibc.clients.mithril.v1.Misbehaviour")
	proto.RegisterType((*MithrilHeader)(nil), "ibc.clients.mithril.v1.MithrilHeader")
	proto.RegisterType((*MithrilStakeDistribution)(nil), "ibc.clients.mithril.v1.MithrilStakeDistribution")
	proto.RegisterType((*CardanoTransactionSnapshot)(nil), "ibc.clients.mithril.v1.CardanoTransactionSnapshot")
	proto.RegisterType((*MithrilCertificate)(nil), "ibc.clients.mithril.v1.MithrilCertificate")
	proto.RegisterType((*CertificateMetadata)(nil), "ibc.clients.mithril.v1.CertificateMetadata")
	proto.RegisterType((*SignerWithStake)(nil), "ibc.clients.mithril.v1.SignerWithStake")
	proto.RegisterType((*ProtocolMessage)(nil), "ibc.clients.mithril.v1.ProtocolMessage")
	proto.RegisterType((*MessagePart)(nil), "ibc.clients.mithril.v1.MessagePart")
	proto.RegisterType((*MithrilProtocolParameters)(nil), "ibc.clients.mithril.v1.MithrilProtocolParameters")
	proto.RegisterType((*CertificateSignature)(nil), "ibc.clients.mithril.v1.CertificateSignature")
	proto.RegisterType((*GenesisSignature)(nil), "ibc.clients.mithril.v1.GenesisSignature")
	proto.RegisterType((*ProtocolGenesisSignature)(nil), "ibc.clients.mithril.v1.ProtocolGenesisSignature")
	proto.RegisterType((*MultiSignature)(nil), "ibc.clients.mithril.v1.MultiSignature")
	proto.RegisterType((*SignedEntityType)(nil), "ibc.clients.mithril.v1.SignedEntityType")
	proto.RegisterType((*CardanoStakeDistribution)(nil), "ibc.clients.mithril.v1.CardanoStakeDistribution")
	proto.RegisterType((*CardanoImmutableFilesFull)(nil), "ibc.clients.mithril.v1.CardanoImmutableFilesFull")
	proto.RegisterType((*CardanoTransactions)(nil), "ibc.clients.mithril.v1.CardanoTransactions")
	proto.RegisterType((*CardanoDbBeacon)(nil), "ibc.clients.mithril.v1.CardanoDbBeacon")
	proto.RegisterType((*ProtocolMultiSignature)(nil), "ibc.clients.mithril.v1.ProtocolMultiSignature")
}

func init() {
	proto.RegisterFile("ibc/clients/mithril/v1/mithril.proto", fileDescriptor_4410ce5523531b7b)
}

var fileDescriptor_4410ce5523531b7b = []byte{
	// 1799 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x73, 0x23, 0x47,
	0x15, 0xd7, 0x48, 0xf2, 0x87, 0x9e, 0x65, 0x5b, 0xdb, 0x32, 0xcb, 0xd8, 0x59, 0x64, 0x23, 0xe7,
	0xc3, 0x24, 0x60, 0xaf, 0x05, 0xa4, 0x20, 0x05, 0x45, 0x49, 0xb2, 0x6c, 0x89, 0xb5, 0x6c, 0xd3,
	0xd2, 0x3a, 0x84, 0xa2, 0x6a, 0xd2, 0x1a, 0xb5, 0xa4, 0x2e, 0x6b, 0x3e, 0x6a, 0xba, 0xe5, 0x60,
	0x2e, 0x54, 0xe5, 0x94, 0x1b, 0x1c, 0x73, 0xdc, 0x2a, 0x4e, 0x14, 0x37, 0xee, 0xdc, 0x73, 0x81,
	0xca, 0x31, 0xa7, 0x00, 0xbb, 0x7f, 0x08, 0xd4, 0xf4, 0xf4, 0x48, 0x23, 0x59, 0xb3, 0xf6, 0x2e,
	0x70, 0x9b, 0x7e, 0xfd, 0x7e, 0xef, 0xfb, 0xbd, 0x7e, 0x12, 0xbc, 0xc9, 0x3a, 0xe6, 0x81, 0x39,
	0x64, 0xd4, 0x16, 0xfc, 0xc0, 0x62, 0x62, 0xe0, 0xb1, 0xe1, 0xc1, 0xf5, 0x61, 0xf8, 0xb9, 0xef,
	0x7a, 0x8e, 0x70, 0xd0, 0x43, 0xd6, 0x31, 0xf7, 0x15, 0xd7, 0x7e, 0x78, 0x75, 0x7d, 0xb8, 0xb5,
	0xd1, 0x77, 0xfa, 0x8e, 0x64, 0x39, 0xf0, 0xbf, 0x02, 0xee, 0xad, 0x42, 0xdf, 0x71, 0xfa, 0x43,
	0x7a, 0x20, 0x4f, 0x9d, 0x51, 0xef, 0xa0, 0x3b, 0xf2, 0x88, 0x60, 0x8e, 0x1d, 0xdc, 0x17, 0x7f,
	0x0c, 0x8b, 0x75, 0xca, 0xfa, 0x03, 0x81, 0xde, 0x82, 0x35, 0x25, 0xcd, 0x18, 0x48, 0x8a, 0xae,
	0xed, 0x68, 0x7b, 0x69, 0xbc, 0xaa, 0xa8, 0x01, 0xdb, 0x07, 0xcb, 0x9f, 0x3d, 0xdb, 0x4e, 0x7c,
	0xfe, 0x6c, 0x3b, 0x51, 0xfc, 0x4b, 0x0a, 0x56, 0xaa, 0xd2, 0x8e, 0x96, 0x20, 0x82, 0xa2, 0x4d,
	0x58, 0x36, 0x07, 0x84, 0xd9, 0x06, 0xeb, 0x4a, 0x68, 0x06, 0x2f, 0xc9, 0x73, 0xa3, 0x8b, 0xaa,
	0xb0, 0x3a, 0x24, 0x82, 0x72, 0x11, 0x8a, 0x4e, 0xee, 0x68, 0x7b, 0x2b, 0xa5, 0xc2, 0xfe, 0x7c,
	0x5f, 0xf6, 0x03, 0x5d, 0x38, 0x1b, 0x80, 0x94, 0x81, 0x55, 0x58, 0xed, 0x79, 0xce, 0x6f, 0xa9,
	0x1d, 0x0a, 0x49, 0xdd, 0x4f, 0x48, 0x00, 0x52, 0x42, 0x76, 0x61, 0xd5, 0x1c, 0x79, 0x1e, 0xb5,
	0x85, 0x41, 0x5d, 0xc7, 0x1c, 0xe8, 0x69, 0xe9, 0x64, 0x56, 0x11, 0x6b, 0x3e, 0x0d, 0x9d, 0xc2,
	0xba, 0xf0, 0x46, 0x5c, 0x30, 0xbb, 0x6f, 0xb8, 0xd4, 0x63, 0x4e, 0x57, 0x5f, 0x90, 0xba, 0x36,
	0xf7, 0x83, 0x70, 0xee, 0x87, 0xe1, 0xdc, 0x3f, 0x52, 0xe1, 0xac, 0x2c, 0x7f, 0xf1, 0xf5, 0x76,
	0xe2, 0xf3, 0x7f, 0x6c, 0x6b, 0x78, 0x2d, 0xc4, 0x5e, 0x48, 0x28, 0xea, 0x40, 0x5e, 0xb2, 0x9b,
	0xce, 0xd0, 0x70, 0x89, 0x47, 0x2c, 0x2a, 0xa8, 0xc7, 0xf5, 0x45, 0x29, 0xf1, 0x30, 0xce, 0xfa,
	0x66, 0xf0, 0x79, 0xa1, 0x90, 0x17, 0x63, 0x20, 0x46, 0xee, 0x2d, 0x1a, 0xfa, 0x36, 0x64, 0x47,
	0x6e, 0xdf, 0x23, 0x5d, 0x6a, 0xb8, 0x44, 0x0c, 0xf4, 0xa5, 0x9d, 0xd4, 0x5e, 0x06, 0xaf, 0x28,
	0xda, 0x05, 0x11, 0x83, 0x0f, 0xd2, 0x7e, 0xe2, 0x8a, 0x9f, 0x26, 0x61, 0xad, 0xea, 0xd8, 0x9c,
	0xda, 0x7c, 0xc4, 0x83, 0xbc, 0x3d, 0x82, 0x8c, 0x60, 0x16, 0xe5, 0x82, 0x58, 0xae, 0xca, 0xf9,
	0x84, 0x80, 0xde, 0x07, 0xbd, 0x67, 0x1a, 0x03, 0xc2, 0x07, 0x86, 0x4a, 0xa1, 0x8c, 0x9b, 0x61,
	0xf1, 0xae, 0xcc, 0x62, 0x06, 0x6f, 0xf4, 0xcc, 0x3a, 0xe1, 0x83, 0x53, 0x79, 0x2b, 0x03, 0xd8,
	0xe4, 0x5d, 0x74, 0x00, 0x1b, 0x8a, 0xdf, 0xa4, 0x9e, 0x08, 0x04, 0xf8, 0x98, 0x94, 0xc4, 0x3c,
	0x08, 0xee, 0xaa, 0xd4, 0x13, 0x3e, 0xd6, 0x07, 0xfc, 0x00, 0xbe, 0x39, 0x57, 0x91, 0xe0, 0x32,
	0x47, 0x19, 0x9c, 0xbf, 0xa5, 0xa7, 0xcd, 0xd1, 0xf7, 0x20, 0x7f, 0x4b, 0x8d, 0xe0, 0x32, 0x5d,
	0x19, 0x9c, 0x9b, 0xd6, 0xd2, 0xe6, 0x2a, 0x08, 0xff, 0xd6, 0x20, 0xdb, 0x64, 0xbc, 0x43, 0x07,
	0xe4, 0x9a, 0x39, 0x23, 0x0f, 0x6d, 0x43, 0x26, 0x48, 0xc1, 0xb8, 0x76, 0x2b, 0x49, 0x5d, 0xc3,
	0xcb, 0x01, 0xb1, 0xd1, 0x45, 0x26, 0xe4, 0x26, 0xcd, 0x41, 0xba, 0xd4, 0x33, 0x0e, 0x55, 0x0d,
	0xbf, 0x75, 0x47, 0x02, 0xeb, 0x92, 0xbd, 0x82, 0x9e, 0x7f, 0xbd, 0xbd, 0x36, 0x45, 0x3a, 0xc4,
	0x6b, 0xd6, 0xd4, 0x79, 0x8e, 0x92, 0x92, 0xaa, 0xf1, 0xd7, 0x56, 0x52, 0x9a, 0x51, 0x52, 0x52,
	0x11, 0x78, 0x91, 0x82, 0xd5, 0x29, 0x46, 0x64, 0xc3, 0x56, 0xa8, 0x9c, 0x0b, 0x72, 0x45, 0x8d,
	0x2e, 0xe3, 0xc2, 0x63, 0x9d, 0x91, 0x5f, 0xdd, 0x32, 0x26, 0x2b, 0xa5, 0xc7, 0x77, 0x98, 0xd1,
	0xf2, 0x81, 0x47, 0x11, 0x1c, 0xd6, 0xad, 0x98, 0x1b, 0xf4, 0x3b, 0x78, 0x3b, 0x5e, 0x9f, 0x4c,
	0x26, 0xeb, 0x31, 0x93, 0x08, 0xaa, 0xe2, 0xfc, 0xee, 0x1d, 0xba, 0xab, 0x13, 0x04, 0xde, 0x8d,
	0xd3, 0x1a, 0x61, 0x42, 0x14, 0x36, 0x84, 0x47, 0x6c, 0x4e, 0x4c, 0xa9, 0x91, 0xdb, 0xc4, 0xe5,
	0x03, 0x27, 0x9c, 0x2a, 0xa5, 0x38, 0x75, 0x55, 0xe2, 0x75, 0x89, 0xed, 0xb4, 0x27, 0xd0, 0x96,
	0x42, 0xe2, 0xbc, 0xb8, 0x4d, 0x44, 0x02, 0x76, 0xe6, 0xa9, 0x99, 0xf2, 0x30, 0xfd, 0xca, 0x1e,
	0x16, 0xe6, 0xa8, 0x8a, 0xdc, 0xab, 0x2c, 0xff, 0x2d, 0x09, 0x7a, 0x5c, 0x6a, 0xd0, 0x06, 0x2c,
	0x04, 0x13, 0x30, 0x68, 0xf9, 0xe0, 0x80, 0x9e, 0x02, 0xe2, 0xac, 0x6f, 0x53, 0x8f, 0x1b, 0x9f,
	0x30, 0x31, 0x08, 0x72, 0xa3, 0x27, 0x77, 0x52, 0x7b, 0x2b, 0xa5, 0x77, 0xe2, 0x0c, 0x6c, 0x49,
	0xc4, 0x87, 0x4c, 0x0c, 0xa4, 0x1a, 0x9c, 0x53, 0x22, 0xc6, 0x14, 0x84, 0x20, 0xed, 0xb7, 0xa6,
	0xea, 0x7e, 0xf9, 0x8d, 0xbe, 0x03, 0xb9, 0x48, 0x10, 0x64, 0xeb, 0xaa, 0x4e, 0x5f, 0x8f, 0xd0,
	0xfd, 0xc6, 0x45, 0xdf, 0x02, 0x30, 0x3d, 0x4a, 0x04, 0xed, 0x1a, 0x44, 0xc8, 0xe6, 0x4e, 0xe3,
	0x8c, 0xa2, 0x94, 0x05, 0xfa, 0x18, 0xd0, 0xed, 0x09, 0xfb, 0xfa, 0x03, 0xf6, 0xc1, 0xad, 0x01,
	0xab, 0xe2, 0xf9, 0x2f, 0x0d, 0xb6, 0xe2, 0xf3, 0xef, 0xbf, 0x2d, 0xe3, 0xf4, 0x4a, 0x6f, 0x82,
	0x57, 0x30, 0x1b, 0x12, 0xa5, 0x2b, 0xdb, 0xb0, 0x62, 0x51, 0xef, 0x6a, 0x48, 0x0d, 0xcf, 0x71,
	0x84, 0x1a, 0xa1, 0x10, 0x90, 0xb0, 0xe3, 0x88, 0xb9, 0x61, 0x49, 0xcd, 0x0f, 0xcb, 0x38, 0x85,
	0xe9, 0x68, 0x0a, 0xdf, 0x87, 0x45, 0xf5, 0x40, 0x2e, 0xdc, 0xeb, 0x81, 0x54, 0xdc, 0xca, 0xc7,
	0xdf, 0xa7, 0x01, 0xdd, 0x2e, 0xb8, 0x71, 0x02, 0xb5, 0x48, 0x02, 0x77, 0x61, 0xd5, 0xf5, 0xa8,
	0x3f, 0x41, 0x79, 0x60, 0x66, 0xe0, 0x4c, 0x36, 0x24, 0x4e, 0xdb, 0x98, 0x8a, 0xda, 0x78, 0xa9,
	0xca, 0xac, 0x6b, 0x50, 0x5b, 0x30, 0x71, 0x63, 0x88, 0x1b, 0x37, 0xec, 0x83, 0xbd, 0x97, 0x96,
	0x59, 0xb7, 0x26, 0x01, 0xed, 0x1b, 0x37, 0xac, 0xb3, 0x08, 0x05, 0x9d, 0xc0, 0xb2, 0x45, 0x05,
	0xe9, 0x12, 0x41, 0x94, 0xf7, 0xef, 0xc5, 0x36, 0xf2, 0xc4, 0xbb, 0xa6, 0x82, 0xe0, 0x31, 0x18,
	0x61, 0xc8, 0x8d, 0x4b, 0xca, 0xa2, 0x9c, 0x93, 0x3e, 0x55, 0x05, 0x15, 0xdb, 0x05, 0x61, 0x25,
	0x35, 0x03, 0x76, 0xbc, 0xee, 0x4e, 0x13, 0xfc, 0x0d, 0x4b, 0x39, 0x1d, 0x4a, 0x5c, 0x92, 0x01,
	0x5b, 0x0d, 0xa8, 0x21, 0xdb, 0x4f, 0x60, 0x8b, 0xf4, 0xfb, 0x1e, 0xed, 0xfb, 0xe9, 0xbf, 0xa6,
	0x5e, 0x60, 0xa4, 0x3f, 0x3c, 0xae, 0xe8, 0x8d, 0xbe, 0x2c, 0x21, 0xfa, 0x98, 0xe3, 0x32, 0xc2,
	0xf0, 0x84, 0xde, 0xa0, 0x9f, 0x43, 0xc6, 0x17, 0x47, 0xc4, 0xc8, 0xa3, 0x7a, 0x46, 0x5a, 0xfc,
	0xdd, 0x7b, 0x84, 0xa0, 0x15, 0x62, 0xf0, 0x04, 0xae, 0x2a, 0xe2, 0xcf, 0x49, 0xc8, 0xcf, 0x09,
	0x96, 0x5f, 0xa8, 0xe3, 0x10, 0x5d, 0x53, 0x8f, 0x87, 0xef, 0x44, 0x66, 0xe2, 0xf9, 0x65, 0x40,
	0x8e, 0x5b, 0x81, 0x92, 0xff, 0xcb, 0x15, 0x68, 0x07, 0x56, 0x98, 0xcd, 0x04, 0x0b, 0x66, 0x82,
	0x2a, 0xb7, 0x28, 0x09, 0x6d, 0xc1, 0x32, 0xa7, 0x64, 0x28, 0xaf, 0x83, 0x8e, 0x19, 0x9f, 0x51,
	0x19, 0x96, 0xd4, 0xd0, 0xd2, 0x17, 0x5e, 0x6d, 0xd8, 0x85, 0x38, 0x15, 0xad, 0x3a, 0xac, 0xcf,
	0x70, 0xf8, 0x8b, 0xb1, 0x4b, 0x3c, 0x71, 0x13, 0x59, 0x8c, 0xe5, 0xb9, 0xd1, 0xf5, 0xbb, 0x23,
	0x9c, 0xb0, 0xb2, 0x3b, 0xe4, 0x41, 0x49, 0x22, 0xb0, 0x3e, 0x53, 0x52, 0xa8, 0x0e, 0xab, 0xaa,
	0x74, 0xfc, 0x30, 0x0a, 0xae, 0x6b, 0xd2, 0xd6, 0xdd, 0xd8, 0x08, 0x06, 0xcc, 0x17, 0xc4, 0x13,
	0x38, 0x6b, 0x4d, 0x0e, 0xa1, 0xb1, 0x7f, 0xd5, 0x60, 0x25, 0xc2, 0x83, 0x18, 0x6c, 0xce, 0x56,
	0xbd, 0x54, 0x24, 0x2b, 0xcf, 0x37, 0x7d, 0xad, 0xb4, 0x7f, 0xcf, 0xf2, 0xf7, 0xe5, 0x3d, 0xa1,
	0x37, 0xf8, 0xa1, 0x3b, 0x97, 0x8e, 0x7e, 0x0a, 0x6f, 0xcc, 0x57, 0x75, 0x4d, 0x86, 0x23, 0xaa,
	0x46, 0x89, 0x3e, 0x07, 0x7c, 0xe9, 0xdf, 0x2b, 0xfb, 0x31, 0x6c, 0xc6, 0x16, 0x09, 0xca, 0x82,
	0x76, 0xa5, 0x1e, 0x37, 0xed, 0xca, 0x3f, 0x59, 0x2a, 0xca, 0x9a, 0x85, 0xf2, 0xb0, 0xe0, 0x0e,
	0x98, 0xd1, 0x93, 0x65, 0xa2, 0xe1, 0xb4, 0x3b, 0x60, 0xc7, 0x4a, 0xe6, 0xdf, 0x35, 0xd8, 0x98,
	0xd7, 0x18, 0xe8, 0x43, 0x78, 0xd0, 0xa7, 0x36, 0xe5, 0x8c, 0x1b, 0x93, 0x0e, 0xd3, 0x5e, 0x3e,
	0xb2, 0x4e, 0x02, 0xc0, 0x58, 0x48, 0x3d, 0x81, 0x73, 0xfd, 0x19, 0x1a, 0xfa, 0x05, 0xac, 0x5b,
	0xa3, 0xa1, 0x60, 0x11, 0xb1, 0x41, 0x67, 0xbc, 0x1d, 0x9b, 0x57, 0x9f, 0x3d, 0x2a, 0x74, 0xcd,
	0x9a, 0xa2, 0x54, 0x00, 0x96, 0x39, 0xeb, 0xcb, 0xa9, 0x5a, 0xfc, 0x54, 0x83, 0xdc, 0xac, 0x1d,
	0xfe, 0xba, 0x37, 0x0e, 0x7f, 0x9c, 0x57, 0x8f, 0xef, 0x4a, 0xf5, 0xac, 0xd4, 0x49, 0xbe, 0x66,
	0x6f, 0x8a, 0x3f, 0x02, 0x3d, 0x0e, 0xe5, 0xff, 0x00, 0x99, 0x56, 0x9d, 0x8d, 0x0c, 0xa1, 0xe2,
	0x9f, 0x34, 0x58, 0x9b, 0xf6, 0x17, 0x35, 0x60, 0x25, 0xfa, 0x6c, 0x68, 0xaf, 0xf8, 0x6c, 0x00,
	0x9d, 0x3c, 0x18, 0xa7, 0x51, 0xdd, 0x41, 0xd4, 0xef, 0xae, 0xf0, 0x29, 0x6b, 0xa2, 0xb6, 0x7e,
	0x95, 0x82, 0xdc, 0xac, 0x3a, 0xe4, 0xfe, 0x3f, 0x36, 0xeb, 0x7a, 0xe2, 0x25, 0xbb, 0xb5, 0x0b,
	0x5b, 0x66, 0xb0, 0xa6, 0xcc, 0xd3, 0x98, 0x7c, 0xb9, 0x46, 0xb5, 0xe0, 0xcc, 0xd5, 0x68, 0xc6,
	0xdc, 0x21, 0x01, 0x8f, 0x42, 0x8d, 0xcc, 0xb2, 0x46, 0x82, 0x74, 0x86, 0xd4, 0xe8, 0xb1, 0x21,
	0xe5, 0x46, 0x6f, 0x34, 0x1c, 0xaa, 0xa5, 0xfa, 0xf0, 0x0e, 0x9d, 0x8d, 0x10, 0x7a, 0xec, 0x23,
	0x8f, 0x47, 0xc3, 0x61, 0x3d, 0x81, 0x37, 0xcd, 0xb8, 0x4b, 0xf4, 0x31, 0x6c, 0x84, 0x5a, 0x23,
	0xfb, 0x30, 0x57, 0x7b, 0xc4, 0x7b, 0xf7, 0x5f, 0xe1, 0x79, 0x3d, 0x81, 0xf3, 0xe6, 0x6d, 0x72,
	0x65, 0x19, 0x16, 0x83, 0x62, 0x29, 0x3e, 0x06, 0x3d, 0x2e, 0x32, 0xf3, 0x57, 0xe9, 0xe2, 0xaf,
	0x61, 0x33, 0xd6, 0x2f, 0xf4, 0x33, 0x58, 0xec, 0x50, 0x62, 0x8e, 0x0b, 0xe0, 0x9d, 0x3b, 0x8c,
	0x3d, 0xea, 0x54, 0x24, 0x3b, 0x56, 0xb0, 0xe2, 0x25, 0xe4, 0xe7, 0xf8, 0xf1, 0xdf, 0xcb, 0x1d,
	0xc1, 0xfa, 0xcc, 0x15, 0xd2, 0x61, 0xc9, 0xa6, 0xe2, 0x13, 0xc7, 0xbb, 0x0a, 0x9f, 0x2f, 0x75,
	0x9c, 0x38, 0x9e, 0x8c, 0x2e, 0x77, 0x25, 0xf8, 0xc6, 0x74, 0x11, 0x18, 0xf6, 0xc8, 0xea, 0x50,
	0x4f, 0xbd, 0xc9, 0x79, 0x16, 0x0d, 0xc7, 0x99, 0xbc, 0x2a, 0x7e, 0x04, 0x0f, 0xe7, 0xb7, 0x17,
	0x2a, 0x00, 0x8c, 0x1b, 0x8c, 0xab, 0xf1, 0x10, 0xa1, 0xf8, 0x0b, 0x75, 0x87, 0x08, 0x73, 0x60,
	0xb8, 0x9e, 0xe3, 0xf4, 0xa4, 0x25, 0x59, 0x0c, 0x92, 0x74, 0xe1, 0x53, 0xde, 0x7d, 0xa6, 0x45,
	0x64, 0x4f, 0x3f, 0x42, 0x79, 0x58, 0x6f, 0x9d, 0x95, 0x2f, 0x5a, 0xf5, 0xf3, 0xb6, 0x71, 0xd4,
	0x38, 0xa9, 0xb5, 0xda, 0xb9, 0x04, 0x7a, 0x13, 0x76, 0xaa, 0x65, 0x7c, 0x54, 0x3e, 0x3b, 0x37,
	0xda, 0xb8, 0x7c, 0xd6, 0x2a, 0x57, 0xdb, 0x8d, 0xf3, 0xb3, 0x96, 0xd1, 0xac, 0xe1, 0x27, 0xa7,
	0x35, 0x03, 0x9f, 0x9f, 0xb7, 0x73, 0x1a, 0xda, 0x85, 0xed, 0xb3, 0xda, 0x2f, 0xdb, 0x46, 0xf9,
	0xe4, 0x04, 0xd7, 0x4e, 0xca, 0xed, 0x9a, 0x71, 0x59, 0xc3, 0x8d, 0xe3, 0x46, 0xb5, 0xec, 0x73,
	0x1b, 0x4f, 0x6a, 0x1f, 0xe5, 0x92, 0x68, 0x07, 0x1e, 0x9d, 0x96, 0xdb, 0xb5, 0x56, 0xdb, 0x68,
	0x34, 0x9b, 0x4f, 0xdb, 0xe5, 0xca, 0x69, 0xcd, 0x38, 0x6e, 0x9c, 0xd6, 0x8c, 0xb3, 0xa7, 0xcd,
	0x4a, 0x0d, 0xe7, 0x52, 0x5b, 0xe9, 0xcf, 0xfe, 0x58, 0x48, 0x54, 0x7e, 0xf8, 0xc5, 0xf3, 0x82,
	0xf6, 0xe5, 0xf3, 0x82, 0xf6, 0xcf, 0xe7, 0x05, 0xed, 0x0f, 0x2f, 0x0a, 0x89, 0x2f, 0x5f, 0x14,
	0x12, 0x5f, 0xbd, 0x28, 0x24, 0x7e, 0xf5, 0x06, 0x67, 0x5d, 0x2a, 0xff, 0x46, 0x3b, 0xf8, 0xcd,
	0xec, 0x7f, 0x83, 0x9d, 0x45, 0x39, 0x6e, 0xbf, 0xff, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf1,
	0x4c, 0x6b, 0x38, 0x39, 0x14, 0x00, 0x00,
}

func (m *Height) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Height) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Height) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MithrilHeight != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.MithrilHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpgradePath) > 0 {
		for iNdEx := len(m.UpgradePath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UpgradePath[iNdEx])
			copy(dAtA[i:], m.UpgradePath[iNdEx])
			i = encodeVarintMithril(dAtA, i, uint64(len(m.UpgradePath[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ProtocolParameters != nil {
		{
			size, err := m.ProtocolParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	n2, err2 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.TrustingPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.TrustingPeriod):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintMithril(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x2a
	if m.CurrentEpoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.CurrentEpoch))
		i--
		dAtA[i] = 0x20
	}
	if m.FrozenHeight != nil {
		{
			size, err := m.FrozenHeight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.LatestHeight != nil {
		{
			size, err := m.LatestHeight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LatestCertHashTs) > 0 {
		i -= len(m.LatestCertHashTs)
		copy(dAtA[i:], m.LatestCertHashTs)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.LatestCertHashTs)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FcHashLatestEpochTs) > 0 {
		i -= len(m.FcHashLatestEpochTs)
		copy(dAtA[i:], m.FcHashLatestEpochTs)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.FcHashLatestEpochTs)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LatestCertHashMsd) > 0 {
		i -= len(m.LatestCertHashMsd)
		copy(dAtA[i:], m.LatestCertHashMsd)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.LatestCertHashMsd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FcHashLatestEpochMsd) > 0 {
		i -= len(m.FcHashLatestEpochMsd)
		copy(dAtA[i:], m.FcHashLatestEpochMsd)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.FcHashLatestEpochMsd)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Misbehaviour) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Misbehaviour) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Misbehaviour) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MithrilHeader2 != nil {
		{
			size, err := m.MithrilHeader2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MithrilHeader1 != nil {
		{
			size, err := m.MithrilHeader1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MithrilHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionSnapshotCertificate != nil {
		{
			size, err := m.TransactionSnapshotCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TransactionSnapshot != nil {
		{
			size, err := m.TransactionSnapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MithrilStakeDistributionCertificate != nil {
		{
			size, err := m.MithrilStakeDistributionCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MithrilStakeDistribution != nil {
		{
			size, err := m.MithrilStakeDistribution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MithrilStakeDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilStakeDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilStakeDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProtocolParameter != nil {
		{
			size, err := m.ProtocolParameter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CreatedAt != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.CertificateHash) > 0 {
		i -= len(m.CertificateHash)
		copy(dAtA[i:], m.CertificateHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.CertificateHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SignersWithStake) > 0 {
		for iNdEx := len(m.SignersWithStake) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignersWithStake[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMithril(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CardanoTransactionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardanoTransactionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardanoTransactionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != nil {
		{
			size, err := m.Height.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CertificateHash) > 0 {
		i -= len(m.CertificateHash)
		copy(dAtA[i:], m.CertificateHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.CertificateHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MerkleRoot) > 0 {
		i -= len(m.MerkleRoot)
		copy(dAtA[i:], m.MerkleRoot)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.MerkleRoot)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SnapshotHash) > 0 {
		i -= len(m.SnapshotHash)
		copy(dAtA[i:], m.SnapshotHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.SnapshotHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MithrilCertificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilCertificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilCertificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AggregateVerificationKey) > 0 {
		i -= len(m.AggregateVerificationKey)
		copy(dAtA[i:], m.AggregateVerificationKey)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.AggregateVerificationKey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SignedMessage) > 0 {
		i -= len(m.SignedMessage)
		copy(dAtA[i:], m.SignedMessage)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.SignedMessage)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ProtocolMessage != nil {
		{
			size, err := m.ProtocolMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SignedEntityType != nil {
		{
			size, err := m.SignedEntityType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PreviousHash) > 0 {
		i -= len(m.PreviousHash)
		copy(dAtA[i:], m.PreviousHash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.PreviousHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertificateMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMithril(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SealedAt != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.SealedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.InitiatedAt != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.InitiatedAt))
		i--
		dAtA[i] = 0x18
	}
	if m.ProtocolParameters != nil {
		{
			size, err := m.ProtocolParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProtocolVersion) > 0 {
		i -= len(m.ProtocolVersion)
		copy(dAtA[i:], m.ProtocolVersion)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ProtocolVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignerWithStake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignerWithStake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignerWithStake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stake != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Stake))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PartyId) > 0 {
		i -= len(m.PartyId)
		copy(dAtA[i:], m.PartyId)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.PartyId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MessageParts) > 0 {
		for iNdEx := len(m.MessageParts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MessageParts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMithril(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MessagePart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessagePart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProtocolMessagePartValue) > 0 {
		i -= len(m.ProtocolMessagePartValue)
		copy(dAtA[i:], m.ProtocolMessagePartValue)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.ProtocolMessagePartValue)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProtocolMessagePartKey != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.ProtocolMessagePartKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MithrilProtocolParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MithrilProtocolParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MithrilProtocolParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PhiF != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PhiF))))
		i--
		dAtA[i] = 0x19
	}
	if m.M != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.M))
		i--
		dAtA[i] = 0x10
	}
	if m.K != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.K))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CertificateSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SigType != nil {
		{
			size := m.SigType.Size()
			i -= size
			if _, err := m.SigType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CertificateSignature_GenesisSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateSignature_GenesisSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GenesisSignature != nil {
		{
			size, err := m.GenesisSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CertificateSignature_MultiSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateSignature_MultiSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MultiSignature != nil {
		{
			size, err := m.MultiSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GenesisSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProtocolGenesisSignature != nil {
		{
			size, err := m.ProtocolGenesisSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolGenesisSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolGenesisSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolGenesisSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EntityType != nil {
		{
			size, err := m.EntityType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignedEntityType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedEntityType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedEntityType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entity != nil {
		{
			size := m.Entity.Size()
			i -= size
			if _, err := m.Entity.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SignedEntityType_MithrilStakeDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedEntityType_MithrilStakeDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MithrilStakeDistribution != nil {
		{
			size, err := m.MithrilStakeDistribution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SignedEntityType_CardanoStakeDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedEntityType_CardanoStakeDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CardanoStakeDistribution != nil {
		{
			size, err := m.CardanoStakeDistribution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SignedEntityType_CardanoImmutableFilesFull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedEntityType_CardanoImmutableFilesFull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CardanoImmutableFilesFull != nil {
		{
			size, err := m.CardanoImmutableFilesFull.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SignedEntityType_CardanoTransactions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedEntityType_CardanoTransactions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CardanoTransactions != nil {
		{
			size, err := m.CardanoTransactions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CardanoStakeDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardanoStakeDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardanoStakeDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CardanoImmutableFilesFull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardanoImmutableFilesFull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardanoImmutableFilesFull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Beacon != nil {
		{
			size, err := m.Beacon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CardanoTransactions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardanoTransactions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardanoTransactions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Beacon != nil {
		{
			size, err := m.Beacon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMithril(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CardanoDbBeacon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardanoDbBeacon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardanoDbBeacon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ImmutableFileNumber != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.ImmutableFileNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintMithril(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Network) > 0 {
		i -= len(m.Network)
		copy(dAtA[i:], m.Network)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Network)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolMultiSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolMultiSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolMultiSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchProof) > 0 {
		i -= len(m.BatchProof)
		copy(dAtA[i:], m.BatchProof)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.BatchProof)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signatures) > 0 {
		i -= len(m.Signatures)
		copy(dAtA[i:], m.Signatures)
		i = encodeVarintMithril(dAtA, i, uint64(len(m.Signatures)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMithril(dAtA []byte, offset int, v uint64) int {
	offset -= sovMithril(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Height) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MithrilHeight != 0 {
		n += 1 + sovMithril(uint64(m.MithrilHeight))
	}
	return n
}

func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.LatestHeight != nil {
		l = m.LatestHeight.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.FrozenHeight != nil {
		l = m.FrozenHeight.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.CurrentEpoch != 0 {
		n += 1 + sovMithril(uint64(m.CurrentEpoch))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.TrustingPeriod)
	n += 1 + l + sovMithril(uint64(l))
	if m.ProtocolParameters != nil {
		l = m.ProtocolParameters.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if len(m.UpgradePath) > 0 {
		for _, s := range m.UpgradePath {
			l = len(s)
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovMithril(uint64(m.Timestamp))
	}
	l = len(m.FcHashLatestEpochMsd)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.LatestCertHashMsd)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.FcHashLatestEpochTs)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.LatestCertHashTs)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *Misbehaviour) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.MithrilHeader1 != nil {
		l = m.MithrilHeader1.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.MithrilHeader2 != nil {
		l = m.MithrilHeader2.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MithrilHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MithrilStakeDistribution != nil {
		l = m.MithrilStakeDistribution.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.MithrilStakeDistributionCertificate != nil {
		l = m.MithrilStakeDistributionCertificate.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.TransactionSnapshot != nil {
		l = m.TransactionSnapshot.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.TransactionSnapshotCertificate != nil {
		l = m.TransactionSnapshotCertificate.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MithrilStakeDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if len(m.SignersWithStake) > 0 {
		for _, e := range m.SignersWithStake {
			l = e.Size()
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.CertificateHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovMithril(uint64(m.CreatedAt))
	}
	if m.ProtocolParameter != nil {
		l = m.ProtocolParameter.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *CardanoTransactionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SnapshotHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.MerkleRoot)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.CertificateHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if m.Height != nil {
		l = m.Height.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MithrilCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.PreviousHash)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if m.SignedEntityType != nil {
		l = m.SignedEntityType.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.ProtocolMessage != nil {
		l = m.ProtocolMessage.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.SignedMessage)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.AggregateVerificationKey)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *CertificateMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProtocolVersion)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.ProtocolParameters != nil {
		l = m.ProtocolParameters.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.InitiatedAt != 0 {
		n += 1 + sovMithril(uint64(m.InitiatedAt))
	}
	if m.SealedAt != 0 {
		n += 1 + sovMithril(uint64(m.SealedAt))
	}
	if len(m.Signers) > 0 {
		for _, e := range m.Signers {
			l = e.Size()
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	return n
}

func (m *SignerWithStake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartyId)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Stake != 0 {
		n += 1 + sovMithril(uint64(m.Stake))
	}
	return n
}

func (m *ProtocolMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MessageParts) > 0 {
		for _, e := range m.MessageParts {
			l = e.Size()
			n += 1 + l + sovMithril(uint64(l))
		}
	}
	return n
}

func (m *MessagePart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolMessagePartKey != 0 {
		n += 1 + sovMithril(uint64(m.ProtocolMessagePartKey))
	}
	l = len(m.ProtocolMessagePartValue)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MithrilProtocolParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K != 0 {
		n += 1 + sovMithril(uint64(m.K))
	}
	if m.M != 0 {
		n += 1 + sovMithril(uint64(m.M))
	}
	if m.PhiF != 0 {
		n += 9
	}
	return n
}

func (m *CertificateSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SigType != nil {
		n += m.SigType.Size()
	}
	return n
}

func (m *CertificateSignature_GenesisSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GenesisSignature != nil {
		l = m.GenesisSignature.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}
func (m *CertificateSignature_MultiSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MultiSignature != nil {
		l = m.MultiSignature.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}
func (m *GenesisSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolGenesisSignature != nil {
		l = m.ProtocolGenesisSignature.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *ProtocolGenesisSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *MultiSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntityType != nil {
		l = m.EntityType.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *SignedEntityType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entity != nil {
		n += m.Entity.Size()
	}
	return n
}

func (m *SignedEntityType_MithrilStakeDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MithrilStakeDistribution != nil {
		l = m.MithrilStakeDistribution.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}
func (m *SignedEntityType_CardanoStakeDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardanoStakeDistribution != nil {
		l = m.CardanoStakeDistribution.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}
func (m *SignedEntityType_CardanoImmutableFilesFull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardanoImmutableFilesFull != nil {
		l = m.CardanoImmutableFilesFull.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}
func (m *SignedEntityType_CardanoTransactions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardanoTransactions != nil {
		l = m.CardanoTransactions.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}
func (m *CardanoStakeDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	return n
}

func (m *CardanoImmutableFilesFull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Beacon != nil {
		l = m.Beacon.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *CardanoTransactions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Beacon != nil {
		l = m.Beacon.Size()
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func (m *CardanoDbBeacon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMithril(uint64(m.Epoch))
	}
	if m.ImmutableFileNumber != 0 {
		n += 1 + sovMithril(uint64(m.ImmutableFileNumber))
	}
	return n
}

func (m *ProtocolMultiSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signatures)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	l = len(m.BatchProof)
	if l > 0 {
		n += 1 + l + sovMithril(uint64(l))
	}
	return n
}

func sovMithril(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMithril(x uint64) (n int) {
	return sovMithril(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Height) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Height: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Height: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilHeight", wireType)
			}
			m.MithrilHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MithrilHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatestHeight == nil {
				m.LatestHeight = &Height{}
			}
			if err := m.LatestHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FrozenHeight == nil {
				m.FrozenHeight = &Height{}
			}
			if err := m.FrozenHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentEpoch", wireType)
			}
			m.CurrentEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustingPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.TrustingPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolParameters == nil {
				m.ProtocolParameters = &MithrilProtocolParameters{}
			}
			if err := m.ProtocolParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradePath = append(m.UpgradePath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FcHashLatestEpochMsd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FcHashLatestEpochMsd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestCertHashMsd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestCertHashMsd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FcHashLatestEpochTs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FcHashLatestEpochTs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestCertHashTs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestCertHashTs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Misbehaviour) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Misbehaviour: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Misbehaviour: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilHeader1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilHeader1 == nil {
				m.MithrilHeader1 = &MithrilHeader{}
			}
			if err := m.MithrilHeader1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilHeader2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilHeader2 == nil {
				m.MithrilHeader2 = &MithrilHeader{}
			}
			if err := m.MithrilHeader2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilStakeDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilStakeDistribution == nil {
				m.MithrilStakeDistribution = &MithrilStakeDistribution{}
			}
			if err := m.MithrilStakeDistribution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilStakeDistributionCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MithrilStakeDistributionCertificate == nil {
				m.MithrilStakeDistributionCertificate = &MithrilCertificate{}
			}
			if err := m.MithrilStakeDistributionCertificate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionSnapshot == nil {
				m.TransactionSnapshot = &CardanoTransactionSnapshot{}
			}
			if err := m.TransactionSnapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionSnapshotCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionSnapshotCertificate == nil {
				m.TransactionSnapshotCertificate = &MithrilCertificate{}
			}
			if err := m.TransactionSnapshotCertificate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilStakeDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilStakeDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilStakeDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignersWithStake", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignersWithStake = append(m.SignersWithStake, &SignerWithStake{})
			if err := m.SignersWithStake[len(m.SignersWithStake)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolParameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolParameter == nil {
				m.ProtocolParameter = &MithrilProtocolParameters{}
			}
			if err := m.ProtocolParameter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardanoTransactionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardanoTransactionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardanoTransactionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Height == nil {
				m.Height = &Height{}
			}
			if err := m.Height.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilCertificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilCertificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilCertificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedEntityType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedEntityType == nil {
				m.SignedEntityType = &SignedEntityType{}
			}
			if err := m.SignedEntityType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &CertificateMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolMessage == nil {
				m.ProtocolMessage = &ProtocolMessage{}
			}
			if err := m.ProtocolMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateVerificationKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregateVerificationKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &CertificateSignature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolParameters == nil {
				m.ProtocolParameters = &MithrilProtocolParameters{}
			}
			if err := m.ProtocolParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedAt", wireType)
			}
			m.InitiatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitiatedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealedAt", wireType)
			}
			m.SealedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SealedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, &SignerWithStake{})
			if err := m.Signers[len(m.Signers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignerWithStake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignerWithStake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignerWithStake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stake", wireType)
			}
			m.Stake = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stake |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageParts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageParts = append(m.MessageParts, &MessagePart{})
			if err := m.MessageParts[len(m.MessageParts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessagePart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessagePart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessagePart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolMessagePartKey", wireType)
			}
			m.ProtocolMessagePartKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolMessagePartKey |= ProtocolMessagePartKey(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolMessagePartValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolMessagePartValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MithrilProtocolParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MithrilProtocolParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MithrilProtocolParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			m.K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.K |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			m.M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.M |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhiF", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PhiF = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GenesisSignature{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SigType = &CertificateSignature_GenesisSignature{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MultiSignature{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SigType = &CertificateSignature_MultiSignature{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolGenesisSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolGenesisSignature == nil {
				m.ProtocolGenesisSignature = &ProtocolGenesisSignature{}
			}
			if err := m.ProtocolGenesisSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolGenesisSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolGenesisSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolGenesisSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EntityType == nil {
				m.EntityType = &SignedEntityType{}
			}
			if err := m.EntityType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &ProtocolMultiSignature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedEntityType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedEntityType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedEntityType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MithrilStakeDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MithrilStakeDistribution{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &SignedEntityType_MithrilStakeDistribution{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardanoStakeDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CardanoStakeDistribution{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &SignedEntityType_CardanoStakeDistribution{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardanoImmutableFilesFull", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CardanoImmutableFilesFull{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &SignedEntityType_CardanoImmutableFilesFull{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardanoTransactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CardanoTransactions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &SignedEntityType_CardanoTransactions{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardanoStakeDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardanoStakeDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardanoStakeDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardanoImmutableFilesFull) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardanoImmutableFilesFull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardanoImmutableFilesFull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beacon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Beacon == nil {
				m.Beacon = &CardanoDbBeacon{}
			}
			if err := m.Beacon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardanoTransactions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardanoTransactions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardanoTransactions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beacon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Beacon == nil {
				m.Beacon = &CardanoDbBeacon{}
			}
			if err := m.Beacon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardanoDbBeacon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardanoDbBeacon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardanoDbBeacon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImmutableFileNumber", wireType)
			}
			m.ImmutableFileNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImmutableFileNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolMultiSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolMultiSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolMultiSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures[:0], dAtA[iNdEx:postIndex]...)
			if m.Signatures == nil {
				m.Signatures = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMithril
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMithril
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchProof = append(m.BatchProof[:0], dAtA[iNdEx:postIndex]...)
			if m.BatchProof == nil {
				m.BatchProof = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMithril(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMithril
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMithril(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMithril
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMithril
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMithril
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMithril
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMithril
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMithril        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMithril          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMithril = fmt.Errorf("proto: unexpected end of group")
)
